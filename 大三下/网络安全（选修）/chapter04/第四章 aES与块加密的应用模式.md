[TOC]

# [XJTU计算机网络安全与管理]——第四讲 AES与块加密的应用模式

## 一、AES引入

### AES起源

很明显 DES需要被改进

具有理论的攻击方式加以破解：*穷举密钥搜索攻击示范*

可以使用 Triple-DES –但是速度较慢而且分块较小

US NIST 1997提出了对加密器的征求

98年六月挑选了15个算法

99年8月进入最后候选

2000年10月**Rijndael获选为AES**

200110月发布为 FIPS（ the Federal Information Processing Standards,(美国)联邦信息处理标准） PUB 197 

### AES需求

**对称块加密**

128-bit 数据,128/192/256-bit 密钥

相比于 Triple-DES 更加快速与安全

实际应用20-30 年(+实际应用)

**提供了完整的规范与设计细节**

同时具有 C & Java 实现

NIST 已经解密了所有提交的和非机密的分析

### AES评估标准

初始标准:

> - *安全性**–**实际密码分析的的效果*
> - *成本**–**依据计算效率*
> - *算法与实现的性能*

最终标准

> - *一般安全性*
> - *软硬件实现*
> - *对于实施的攻击*
> - *灵活性(in en/decrypt, keying, other factors)*

#### AES名单

经过测试与评估,99年8月提出的shortlist名单: 

> *MARS (IBM)- complex, fast, high security margin*
>
> *RC6 (USA)- v. simple, v. fast, low security margin*
>
> *Rijndael(Belgium)- clean, fast, good security margin*
>
> *Serpent (Euro)- slow, clean, v. high security margin*
>
> *Twofish(USA)- complex, v. fast, high security margin*

然后对其进行更进一步的 analysis & comment

在算法中进行对比

> *复杂论变换与简单变换*
>
> *现有加密器与新标准*

## 二、The AES 加密器- Rijndael 

由比利时 Rijmen-Daemen设计

<mark>有128/192/256 bit 密钥,128 bit 数据</mark>——记住

一个胜于**feistel加密器的迭代**

> *把数据作为**4**字节**4**列的块进行处理*
>
> *在每一轮对整个数据块进行操作*

设计以达到:

> *抵抗已知攻击*
>
> *在许多CPUs上的速度与代码的紧致*
>
> *设计的简明*

### 总体结构

<mark>明文分组的长度为128位即16字节，密钥长度可以为16字节，24字节或32字节(128位，192位或256位)</mark>。根据密钥的长度，算法被称为AES-128,AES-192或AES-256。

加密和解密算法的输入是一个128位分组。在FIPS PUB197里，这个分组被描述为**4×4的字节方阵**。这个分组被复制到**state数组**，并在加密或解密的各个阶段被修改。同样地，密钥也被描述为字节的方阵。这个密钥接着被扩展为密钥字阵列。每个字是4字节，**128位的密钥最终扩展为44字的序列**。

<mark>轮数要记住</mark>

| 位数 | 128bit | 192bit | 256bit |
| ---- | ------ | ------ | ------ |
| 轮数 | 10轮   | 12轮   | 14轮   |

在9/11/13 轮中state做下面变化——<mark>**这四步需要掌握**</mark> ，最后一轮是三步

> :one: *字节替代**(1 S-box**用在每一个字节)*
>
> :two: *行移位(permute bytes between groups/columns)*
>
> :three: *列混淆(subs using matrixmultipyof groups)*
>
> :four: *加轮密钥**(**将轮密钥与**state**XOR)*
>
> ![image-20220603210857059](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220603210857059.png)
>
> ![image-20220603210847367](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220603210847367.png)
>
> *可以看做交替的使用轮密钥XOR与对数据字节进行扰乱的操作*

![image-20220426113336447](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220426113336447.png)

#### 字节替代

对每个字节进行简单的替代操作

使用一个16x16 字节的表，其中包含了256个8bit值的置换

每个state的字节通过查表左4bits的行号与右4bit的列号替代

> 比如byte {95}被第9 行第5列的{2A}替代

S-box 的构造利用了 GF(2^8^)上值的变换

被设计来抵抗已知的攻击

#### 行移位

对行进行循环移位操作

> *1st row不变*
>
> *2nd row左移一个字节*
>
> *3rd row左移两个字节*
>
> *4th row左移三个字节*
>
> ![image-20220603201338354](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220603201338354.png)

解密逆操作使用右移相应字节的方式实现

由于 state 是按照列进行操作的,这一步在列之间进行了字节置换操作

#### 列混淆——要会算

每一列均单独处理

每个字节均由一个与其同列的4个字节相关值替代

使用GF(2^8^)上的矩阵乘运算使用的“素”多项式<mark>m(x)=x^8^+x^4^+x^3^+x+1</mark>

> 解密的时候只需要求该矩阵的逆即可

![image-20220426113735852](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220426113735852.png)

> 01:1	02:x	03:x+1

乘积矩阵中的每个元素均是一行和一列中的对应元素的乘积之和。在这里的乘法和加法都是定义在GF(2^8^)(加法对应异或）上的。状态中单列的列混淆变换表示为

<img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220603201837344.png" alt="image-20220603201837344" style="zoom:50%;" />

**举例说明**

![image-20220603202703897](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220603202703897.png)

对87->47进行说明：

即说明$(\{02\}\cdot\{87\})\oplus(\{03\}\cdot\{6E\})\oplus\{46\}\oplus\{A6\}=\{47\}$
$$
\begin{aligned}
&\{02\}\cdot\{87\}=(00000010)\cdot(1000 0111)\mod （1\ 0001\ 1011)=(1\ 0000\ 1110)\mod (1\ 0001\ 1011)=(0001\ 0101)\\
&\{03\}\cdot\{6E\}=\{6E\}\oplus \{02\}\cdot\{6E\}=(0110\ 1110)\oplus(1101\ 1100)=(1011\ 0010)\\
&所以(\{02\}\cdot\{87\})\oplus(\{03\}\cdot\{6E\})\oplus\{46\}\oplus\{A6\}=(0001\ 0101)\oplus (1011\ 0010)\oplus (0100\ 0110)\oplus (1010\ 0110)=\{47\}
\end{aligned}
$$

#### 加轮密钥

XOR(异或) state 使用128-bits 的轮密钥

再一次以列为单位操作(通过一系列以字节为单位的操作)

作为逆操作解密使用同样的密钥：*因为XOR是其本身的逆操作*

被设计为尽可能的简单

*安全性的满足来自于密钥扩展的复杂性和**AES**其它阶段运算的复杂性*

![image-20220603210801403](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220603210801403.png)

## 三、AES密钥扩展——了解即可

> 使用128-bit (16-byte)密钥并扩展为44/52/60 32-bit words 的数组
>
> 将初始密钥拷贝到最初4 words
>
> 然后循环利用4个words填充剩下的部分
>
> > 与**i-1与i-4**相关
> >
> > 4种情况中的3种只是使用XOR 操作
> >
> > 对于下标被4整除的要经过循环移位+ S-box + XOR 轮系数操作,然后再与上一轮第一个XOR

设计以抵抗已知攻击

> 知道密钥或轮密钥的部分位不足以知道其它位
>
> 可逆变化
>
> 可以在各种CPU上有效的执行
>
> 使用轮常量以排除对称性
>
> 将密钥差异扩散到轮密钥中
>
> 足够的非线性
>
> 易于描述

## 四、AES解密

![image-20220615192055315](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220615192055315.png)

AES **解密与加密并不相同因为步骤是相反**的

可以**定义一个等价的解密算法使其具有与加密相同的结构**

> 但是在**每一步使用了相应的逆变换**
>
> 密钥策略有所变化（除了第一和最后一轮轮密钥需要经过逆列混淆变换再XOR）

效果不变因为下面的变化成立

> 交换字节替代&行移位
>
> 交换列混淆&加(tweaked)轮密钥

## 五、块加密的应用模式——填空/选择/判断

对于块定长，密钥长度定长的块加密算法

实际应用当中常常需要加密任意长的数据

**ANSI X3.106-1983中定义了四种应用方式**

**后来发展为 5 类应用于像 AES & DES的算法**

> <mark>五种安全模式(考点)</mark>：ECB、CBC、CFB、OFB、CTR——填空
>
> 块模式(ECB、CBC)
>
> 流模式(CFB、OFB、CTR)	
>
> 优缺点——选择判断
>
> 并行处理：ECB、CTR

### 电子密码本Electronic Codebook Book (ECB)

明文被分块独立加密，明文块与密文块具有一一对应的关系。就像密码本。

$C_i=DES_{K1}(P_i)$

**用于单一值的安全传输**

![image-20220429082617789](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220429082617789.png)

**优缺点**

明文块的重复会体现在密文当中，当报文量很小时没什么，但当报文量大的时候，特别是报文具备结构性特征：比如总是以某些事先规定好的域开始。那么分析者有可能获得很多可供分析的明文-密文对。结合64bit的划分，给篡改，重排带来隐患

<mark>应用范围：*小规模数据传输（几块）*</mark>

### 密码分组链接方式Cipher Block Chaining (CBC)——比较常用

消息经过分块；通过加密操作将分块链接起来；通过**将前一个密文块与当前明文块**连接（异或）因而得名

步骤开始时利用一个初始值
$$
C_i=DES_{K1}(P_i\oplus\ C_{i-1})\\
C_{-1}=IV
$$
用于：**大量数据的加密**，鉴别（http，email,ftp)

![image-20220429082958702](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220429082958702.png)

#### 消息填充

消息最后可能需要处理一个小分组，这是需要进行消息填充

填充方法可以是填入空值，也可以是填入填充值。

> *Eg：* *[ b1 b2 b3 0 0 0 0 5]* 
>
> *就是说**8**个字节前面三个是消息，后面五个是填充*

这样的填充有可能需要一个完整的块

某些更加深奥的方法可能避免该块

#### CBC优缺点——选择判断

<mark>每一块都依赖于其前面所有的块</mark>

<mark>对一块的改变可影响其后所有</mark>——最后一个块可以作为校验码

初始向量IV

> *需要双方知道*
>
> *若明文传输，攻击者有可能篡改*
>
> *用固定文字（**EFTPOS**）*
>
> *先用**ECB**加密传。*

### 密码反馈模式 Cipher FeedBack (CFB)

消息被<mark>**作为一个数据流对待**</mark>

添加到加密器的后端

结果被反馈在后面的过程中（由此得名）

标准允许任意长度的比特数。 CFB-1, CFB-8, CFB-64, CFB-128 etc
$$
C_i=P_i\oplus DES_{K1}(C_{i-1})\\
C_{-1}=IV
$$
用于：**流数据加密**，鉴别

#### CFB优缺点

适应于数据一比特或字节到达

<mark>最常见的流模式</mark>

每过n比特需要等待块加密

加密过程应用于两端

**错误影响其后多个块**

### 输出反馈模式Output FeedBack (OFB)

消息被作为**数据流对待**；加密结果被加到消息上；输出的是接下来的反馈；**反馈独立于消息**

$$
C_i=P_i\oplus O_i\\
O_i=DES_{K1}(O_{i-1})\\
O_{-1}=IV
$$
<mark>用于噪声信道</mark>

#### 优缺点

**比特错误不会传播**

易受报文篡改攻击

双方应保持同步

目前用的就是64bit与128bit的

### Counter——CTR

一个新的方式

与OFT相似但是加密的是**对应值（ counter value）而不是反馈值**

每个明文块都要有不同的密钥与对应值
$$
C_i=P_i\oplus O_i\\
O_i=DES_{K1}(i)\\
$$
用于**高速网络加密传播**——WIFI

#### 优缺点

**高效**

> *可并行*
>
> *可预处理*
>
> *爆发性高速连接*

随机存取加密块

可证安全

需保证密钥与对应值不复用

## 参考资料

[1] 西安交通大学计算机网络安全与管理2022年春PPT 	田暄

[2] 密码编码学与网络安全（第七版），William Stallings著，王后珍等译