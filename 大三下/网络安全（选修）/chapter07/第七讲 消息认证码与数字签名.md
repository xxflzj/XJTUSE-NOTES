[TOC]

# [XJTU计算机网络安全与管理]——第七讲消息认证码和数字签名

## 一、消息认证码

### 消息认证——MessageAuthentication

Message：消息、报文。

Authentication：鉴别、认证。

认证：消息的接收者对消息进行的验证。

> **真实性**：消息确实来自于其真正的发送者，而非假冒；
>
> **完整性**：消息的内容没有被篡改。

### 消息认证函数

任何消息认证或数字签名机制在功能上都分为两层。在下层中，有某类生成认证符的函数，其中**认证符是一个用来认证消息的值**；下层函数然后被用作上层认证中的一个原语，便于让接收方验证消息真实性。

可以**用来生成认证符的函数**

> :one:哈希函数：以hash值作为认证符
>
> :two:消息加密：对整个消息加密后的密文作为认证符
>
> :three:消息认证码MAC（是消息与密钥的函数，生成定长值作为认证符）

#### 消息加密

消息加密本身也提供了认证作用

:one:若是用的是对称加密

> 接收方知道发送方一定做了加密动作
>
> 因为只有发送方与接收方知道密钥
>
> 知道消息没有被变更过
>
> 若消息结构恰当，则可以通过适当的冗余与检查和探测变更。

:two:若使用公钥加密

> 加密没有保证发送方身份因为任意人都可能知道公钥
>
> 然而：若发送方使用的是私钥签名消息然后使用接收方的公钥加密则同时提供了安全性与身份认证
>
> 需要能够认出计算的消息，对消息需要两方计算



![image-20220605150330962](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220605150330962.png)

##### 内部错误控制与外部错误控制（附加额外信息）

问题：B如何判断收到的密文X的合法性？

> 如果消息M是具有某种语法特征的文本，或者M本身具有一定的结构：B可通过分析Y的语法或结构特征。
>
> 如果消息M是完全随机的二进制比特序列：B无法判断是否正确恢复密文。

解决这个问题的方法之一是，**要求明文具有某种易于识别的结构，并且不通过加密函数是不能重复这种结构的**。例如，可以在加密前对每个消息附加一个**错误检测码，也称之为帧校验序列(FCS)或校验和**，如图12.2(a)所示。A准备发送明文消息M,那么A将M作为F的输入，产生FCS,将FCS附加在M后**并对M和FCS一起加密**。在接收端，B解密其收到的信息，并将其视为消息和附加的FCS，B用相同的函数F重新计算FCS。若计算得到的FCS和收到的FCS相等，则B认为消息是真实的。任何随机的位串不可能产生M和FCS之间的上述联系。



![image-20220605151304270](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220605151304270.png)

请注意，FCS和加密函数执行的顺序很重要。文献[DF℉79]中将图12.2()所示的这种序列称为
**内部错误控制**，以与外部错误控制[参见图12.2b)]对应。对于内部错误控制，由于攻击者很难产生密文，使得解密后其错误控制位是正确的，因此内部错误控制可以提供认证；如果FCS是外部码，那么攻击者可以构造具有正确错误控制码的消息，虽然攻击者不知道解密后的明文是什么，但他可以造成混淆并破坏通信。

### 认证与保密

是构成信息系统安全的两个方面，但属于两个不同属性上的问题：

> 认证不能自动提供保密性；
>
> 保密性也不能自然提供认证功能

### 消息认证码MAC

消息认证码（密码校验或MAC）也是一种认证技术。作为消息和密钥的函数
$$
MAC=C(K,M)
$$
MAC与加密类似。区别之一是MAC**不要求可逆而加密算法必须可逆**。

#### 消息认证码的功能

:one:如果B端通过比较发现MAC匹配，则可确信报文M没有被篡改过（**完整性**）

> 若攻击者更改报文内容而末更改MAC，则接收者计算出的MAC将不同于接收到的MAC；
>
> 由于攻击者不知道密钥K，故他不可能计算出一个与更改后报文相对应MAC值。

:two:接收者B也能够确信报文M是来自发送者A的（**真实性**）

> 只有A了解密钥K，也只有A能够计算出报文M所对应的正确的MAC值。

#### 消息认证码

通过某种算法构造，大小固定的小块

> 依赖于消息与某些密钥
>
> 像加密但是不需要可逆性

<mark>追加在消息后作为签名</mark>

接收方依据消息进行某些计算并检验其值与MAC匹配从而确认消息没有被变更并来源于发送方

若消息中有序号，则接收方可以相信消息的顺序是正确的

![image-20220605154142878](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220605154142878.png)

:key:MAC提供了认证作用，能够使用加密以保障安全性

> 通常每次使用单独的密钥
>
> 可以在加密前或加密后进行加密，但通常在之前

:question:为什么需要MAC

> 有的时候仅仅需要认证
>
> 有时需要认证的作用长于对加密的需要（比如档案）

<mark>MAC不是数字签名</mark>

#### MAC函数与加密函数比较——重要（选择填空判断简答）

:one:两者类似，都需要密钥。

:two:MAC函数可以是一个单向函数，而加密函数必须是可逆的。

> MAC鉴别函数的这个数学性质使得它比加密函数**更不易被破解。**

:three:**MAC算法不能提供信息的保密性，保密性可以通过对消息加密来提供。**

> 两种方式：
>
> 1.先计算MAC再加密；
>
> 2.先加密再计算MAC。
>
> 需要两个独立的密钥。

:four:基于MAC的消息认证方式其认证的过程是独立于加密和解密过程。

> 与基于加密的认证方式是不同的；
>
> 认证函数与保密函数的分离能提供结构上的灵活性。

:five:MAC方式更适合不需要加密保护的数据的认证。

> 在某些应用中，认证报文的真实性比报文的保密性更重要。

#### 安全性分析——了解

MAC函数的特性

:one:为多对一映射。

> M相同，存在多个Key产生相同的MAC；
>
> Key相同，多个M产生相同的MAC。

:two:n-bitMAC：有2^n^个可能的MAC。

:three:k-bit密钥：有2^k^个可能的密钥(n<k)。

:four:N种可能的消息。显然，N>>2n。

#### 基于hash函数的MAC——HMAC

HMAC将哈希函数视为一个模块具有两个优点

> 可以预先封装许多HMAC代码
>
> 若希望替代可以很方便

针对HMAC的攻击要么是针对密钥的穷举攻击，要么是生日攻击。由于K的参与，无法使用离线计算寻找碰撞，需要长时间观察收集消息-MAC对。这使得MD5这样的嵌入哈希函数也完全可以被接受

#### 基于分组密码的MAC——DAA和CMAC

基于DES的数据认证算法（DAA0）十多年广泛使用的MAC算法之一。

DAA存在如下的限制；仅能处理长度固定为mn的消息，其中n是密文分组的长度，m是一个固定的正整数。这样的限制可以使用三个密钥来克服：一个长度为k的K，用在密文分组链接的每一步中；两个长度为n的密钥（可以由加密密钥导出）。

## 二、数字签名

### 概述

消息认证可以保护信息交换双方不受第三方的攻击，但是它不能处理通信双方自身发生的攻击，这种攻击可以有多种形式。

例如，假定John给Mary发送一条认证消息。考虑下面两种情形：

:one:Mary可以伪造一条消息并称该消息发自John。Mary只需产生一条消息，用John和Mary共享的密钥产生认证码，并将认证码附于消息之后。

:two:John可以否认曾发送过某条消息。因为May可以伪造消息，所以无法证明John确实发送过该消息。

这两种情形都是法律关注的。例如，对于第一种情形，在进行电子资金转账时，接收方可以增加转账资金，并声称这是来自发送方的转账资金额；对于第二种情形，股票经纪人收到有关电子邮件消息，要他进行一笔交易，而这笔交易后来赔钱了，但是发送方可以伪称从未发送过这条消息。**在收发双方不能完全信任的情况下，就需要除认证之外的其他方法来解决这些问题。**数字签名是解决这个问题的最好方法。

数字签名必须具有下列特征：

> :one:能够验证签名者，签名日期和时间
>
> :two:能够认证被签名的消息内容
>
> :three:出现争执时能够被第三方仲裁

数字签名具有认证功能

![image-20220605160441645](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220605160441645.png)

**数字签名要求**

- 签名必须依赖于正被签名的位模式
- 签名必须使用只有发送方知道的某些信息，以防止伪造和否认
- 生成数字签名比较容易
- 识别和验证数字签名比较容易
- 伪造数字签名在计算上是不可行的
- 保存数字签名的副本是可行的。

**直接数字签名**

- 指只涉及通信双方的数字签名方案。假设是接收方已知发送方的公钥
- 发送方可以用自己的私钥对消息或消息的hash值进行加密
- <mark>先执行签名函数侯执行外层保密函数很重要</mark>
- 私钥的安全性与签名的有效期等问题可以用证书技术加以解决。

### EIGamal数字签名方案

<mark>需要掌握,考ElGamal数字签名方案是使用私钥进行加密,公钥进行解密</mark>

对于素数q，如果α是q的本原根，则有α，α^2^，···，α^q−1^ mod q的结果各不相同。进一步,有:

> :one: 对任意整数m，$α^m≡1(\ \text{mod}\ q)$ 当且仅当 $m≡0(\ \text{mod}\ q−1)$
>
> :two: 对任意整数i，j，$α^i≡α^j(\ \text{mod}\ q)$ 当且仅当$ i≡j(\ \text{mod}\ q−1$).
>

ElGamal数字签名方案的基本元素是素数q和α，其中α是q的本原根。用户A通过如下步骤产生公钥/私钥对:

> :one: 生成随机整数X~A~,使得1 < X~A~< q−1
>
> :two: 计算$Y_A=α^{X_A}\ \text{mod}\ q$
>
> :three: A的私钥是X~A~；A的公钥是{a，α，Y~A~}

为了对消息M进行签名,用户A首先计算Hash值m=H(M),这里m是满足0⩽m⩽q−1的整数。然后A通过如下步骤产生数字签名:

> :one: 选择随机整数K,使得满足1⩽K⩽q−1以及gcd(K，q−1)=1,即K与q−1互素;
>
> :two: 计算$S_1=a^K\ \text{mod}\ q$，这同ElGamal加密方案中C1的计算相同
>
> :three: 计算$K^{−1}\ \text{mod}\ (q−1)$，即计算K模q−1的逆;
>
> :four: 计算$S_2=K^{−1}(m−X_AS_1)\ \text{mod}\ (q−1)$;
>
> :five: 签名包括$(S1,S_2)$对.

任意用户B都能通过如下步骤验证签名:

> :one: 计算$V_1=α^m\ \text{mod}\ q$
>
> :two: 计算$V_2=(Y_A)^{S_1}(S_1)^{S_2}\ \text{mod}\ q$
>
> :three: 如果$V_1=V_2$则签名合法.

#### 举例

例如，对于素数域GF(19)，即q=19,如表2.7所示，其原根是{2,3,10,13,14,15}。我们选择α=10。

Alice通过如下步骤产生密钥对：

:one: Alice选择$X_A=16$。

:two: 则$Y_A=\alpha^{X_A}\ \text{mod}\ q=10^{16}\ \text{mod}\ 19=4$

:three: Alice的私钥是16；Alice的公钥是{a，α，Y~A~}={19,10,4}。

假设Alice要对Hash值m=14的消息进行签名：

:one: Alice选择$K=5$,其与$q-1=18$互素。

:two: $S_1=\alpha^k \ \text{mod}\ q=10^5\ \text{mod}\ 19=3$

:three: $K^{−1}\ \text{mod}\ (q−1)=5^{-1}\ \text{mod}\ 18=11$ 

:four: $S_2=K^{−1}(m−X_AS_1)\ \text{mod}\ (q−1)=11(14-(16)(3))\ \text{mod}\ 18=-374\ \text{mod}\ 18=4$

Bob能够通过如下步骤验证签名：

:one: $V_1=α^m\ \text{mod}\ q=10^{14}\ \text{mod}\ 19=16$ 

:two: $V_2=(Y_A)^{S_1}(S_1)^{S_2}\ \text{mod}\ q=4^33^4\ \text{mod}\ 19=5184\ \text{mod}\ 19=16 $ 

因为$V_1=V_2$所以签名是合法的。

### Schnorr   签名方案

基于离散对数, 

### DSA

<mark>DSA  使用的是只提供数字签名功能的算法,  与RSA  不同,  不能用于加密与密钥交换**(只考这个概念,  判断,  选择).**</mark>

## 参考资料

[1] 西安交通大学计算机网络安全与管理2022年春PPT 	田暄

[2] 密码编码学与网络安全（第七版），William Stallings著，王后珍等译

