<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="第四章 语法分析——自上而下分析" _note="**语法分析的前提**&#10;&#10;&gt; 对语言的语法结构进行描述&#10;&gt;&#10;&gt; &gt; 采用**正规式和有限自动机**描述和识别语言的单词符号&#10;&gt; &gt;&#10;&gt; &gt; 用上下文无关文法来描述语法规则&#10;&#10;语法分析的任务:分析一个文法的句子的结构&#10;&#10;语法分析器的功能:按照文法的产生式(语言的语法规则)，识别输入符号串是否为一个句子(合式程序)&#10;&#10;**语法分析的方法**&#10;&#10;&gt; 1️⃣ 自上而下Top-down&#10;&gt;&#10;&gt; &gt; 从文法的开始符号出发,反复使用各种产生式，寻找&quot;匹配&quot;的推导&#10;&gt; &gt;&#10;&gt; &gt; 推导：根据文法的产生式规则,把串中出现的产生式的左部符号替换成右部&#10;&gt; &gt;&#10;&gt; &gt; 从树的根开始，构造语法&#10;&gt; &gt;&#10;&gt; &gt; 递归下降分析法、预测分析程序&#10;&gt;&#10;&gt; 2️⃣ 自下而上Bottom-up&#10;&gt;&#10;&gt; &gt; 从输入串开始， 逐步进行归约,直到文法的开始符&#10;&gt; &gt;&#10;&gt; &gt; 归约：根据文法的产生式规则,把串中出现的产生式的右部替换成左部符号&#10;&gt; &gt;&#10;&gt; &gt; 从树叶节点开始,构造语法树&#10;&gt; &gt;&#10;&gt; &gt; 算符优先分析法、LR分析法">
  <outline text="语法分析的任务与分类" _note="语法分析的任务：*对**任**一**给**定**w* ∈ *V*_(*T*)^(\*), *判**断**w* ∈ *L*(*G*)&#10;&#10;&gt; w表示终结符串&#10;&gt;&#10;&gt; 句子的全体是一个语言，记作L(G)&#10;&#10;语法分析器是一个程序，它按照P，做识别w的工作&#10;&#10;![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220317230038342.png)">
  </outline>
  <outline text="自上而下分析面临的问题" _note="**主旨**：从文法开始符号出发，自上而下地为输入串建立一棵语法树。&#10;&#10;**举例**：文法G1: S -&amp;gt; cAd A -&amp;gt;&#10;ab|a，输入串：w=cad，为它建立语法树&#10;&#10;![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220320224303932.png)&#10;&#10;上述分析方法的实现：&#10;&#10;1️⃣&#10;每一非终结符对应一个递归子程序，在只生成两个串的文法中过程无须递归;但是，对于生成无数个串的文法而言，递归不可避免。&#10;&#10;2️⃣&#10;递归子程序是一个布尔过程，一旦它发现自己的某个候选式与输入串匹配，它就按此式扩充语法树，返回true,指针移过已匹配子串;否则，返回false,保持原来的语法树和指针不变。&#10;&#10;**程序实现**&#10;&#10;&gt; 使用两个过程: S()和A()， 它们送回true or&#10;&gt; false,决定于它们是否在输入串中找到相应的终结符所构成的串。&#10;&#10;**使用记号**&#10;&#10;&gt; input\_ symbol:当前符号内容  &#10;&gt; input\_ pointer: 输入字符指针&#10;&#10;**使用过程**&#10;&#10;&gt; ADVANCE():把input\_ pointer移&#10;&gt; 到下一输入符号位置，置input\_symbol是当前符号内容。&#10;&#10;    procedure S();&#10;    begin &#10;    	if input_symbol = 'c' then&#10;    	begin&#10;    		ADVANCE();&#10;    		if A() then//A扩展&#10;    			if input_symbol = 'd'&#10;    			then &#10;    				begin&#10;    					ADVANCE();//指针后移&#10;    					return true;&#10;    				end;&#10;    	end;&#10;    	return false;&#10;    end;&#10;&#10;    procedure A();&#10;    begin&#10;    	isave := input_pointer;//记录输入指针，防止回滚&#10;    	if input_symbol = 'a' then&#10;    	begin&#10;    		ADVANCE();&#10;    		if input_symbol = 'b' then&#10;    			begin&#10;    				ADVANCE();&#10;    				return true;&#10;    			end;&#10;    	end;&#10;    /* 匹配ab失败，则匹配a*/&#10;    	input_pointer := isave//将之前记录的输入指针赋值给输入指针&#10;    	if input_symbol = 'a' then&#10;    		begin&#10;    			ADVANCE();&#10;    			return true;&#10;    		end;&#10;    	else&#10;    		return false;&#10;    end;&#10;&#10;**困难和问题**&#10;&#10;-   文法的左递归&#10;&#10;-   回溯&#10;&#10;-   使用候选式的顺序会影响所接受的语言: 如: A -&amp;gt; ab|a改为A-&amp;gt;a|ab&#10;&#10;-   难以报告出错的确切位置&#10;&#10;-   穷举试探法一 低效的分析方法">
  </outline>
  <outline text="自上而下分析的问题如何解决" _note="消除文法左递归以及回溯问题">
    <outline text="区分三种类型的左递归" _note="1️⃣ 直接左递归&#10;&#10;形如：N-&amp;gt;Nα&#10;&#10;2️⃣ 间接左递归&#10;&#10;形如：N-&amp;gt;Aα A-&amp;gt;Bβ B-&amp;gt;Nγ&#10;&#10;3️⃣ 潜在左递归&#10;&#10;形如：N-&amp;gt;α N β，而$\\alpha\\overset{+}{\\Rightarrow}ε$">
    </outline>
    <outline text="直接左递归的消除" _note="候选式：A-&amp;gt;Aα|β，可以得到文法符号串：βα、βαα、βααα……&#10;&#10;A-&amp;gt;βA' A'-&amp;gt;α A'|ε，也可以得到文法符号串：βα、βαα、βααα……&#10;&#10;一般化可以得到直接左递归的消除方法&#10;&#10;&gt; **若：A-&amp;gt;Aα|β，其中β不以A开头，则修改规则为A-&amp;gt;βA' A'-&amp;gt;α&#10;&gt; A'|ε**&#10;&gt;&#10;&gt; 可以进行推广：假定P的全部产生式为&#10;&gt;&#10;&gt; *P* → *P**α*₁|*P**α*₂|...|*P**α*_(*m*)|*β*₁|*β*₂|...|*β*_(*n*)&#10;&gt;&#10;&gt; 每个α都不等于ε，每个β都不以P开头&#10;&gt;&#10;&gt; 则将左递归变为右递归如下&#10;&gt;&#10;&gt; $$P\\rightarrow\\beta\_1P'|\\beta\_2P'|...|\\beta\_nP'\\\\&#10;&gt; P'\\rightarrow\\alpha\_1P'|\\alpha\_2P'|...|\\alpha\_mP'|ε$$&#10;&#10;**举例**：文法：E-&amp;gt;E+T|T T-&amp;gt;T\*F|F F-&amp;gt;(E)|i&#10;&#10;&gt; 消除直接左递归后&#10;&gt;&#10;&gt; E-&amp;gt;TE'&#10;&gt;&#10;&gt; E'-&amp;gt;+TE'|ε&#10;&gt;&#10;&gt; T-&amp;gt;FT'&#10;&gt;&#10;&gt; T'-&amp;gt;\*FT'|ε&#10;&gt;&#10;&gt; F-&amp;gt;(E)|i">
    </outline>
    <outline text="间接和潜在左递归的消除" _note="一个文法消除左递归的条件：不含以ε为右部的产生式；不含回路$P\\overset{+}{\\Rightarrow}P$&#10;&#10;**代入法**&#10;&#10;&gt; 将一个产生式规则右部的a中的非终结符N替换为“N的候选式”。如果N有n个候选式，则右边的a重复n次，而且每一次重复都用N的**不同候选式**来代替N。&#10;&gt;&#10;&gt; 举例：（改写之后的）N-&amp;gt;a|Bc|ε在S-&amp;gt;pNq中的代入结果：S-&amp;gt;paq|pBcq|pq">
    </outline>
    <outline text="消除一个文法一切左递归的算法" _note="1️⃣ 对文法G的所有非终结符进行排序；&#10;&#10;2️⃣ 按上述顺序对每一个非终结符Pi依次执行：&#10;&#10;    for(j=1;j&lt; i-1；j++)&#10;    	将Pj代入Pi的产生式（若可代入的话);&#10;    消除关于Pi的直接左递归;&#10;&#10;3️⃣ 化简上述所得文法。&#10;&#10;**举例**&#10;&#10;&gt; 对于文法：S-&amp;gt;Qc|c Q-&amp;gt;Rb|b R-&amp;gt;Sa|a&#10;&gt;&#10;&gt; 虽然没有直接左递归，但是S,Q,R都是左递归的，比如有S=&amp;gt;Qc=&amp;gt;Rbc=&amp;gt;Sabc&#10;&gt;&#10;&gt; 1️⃣ 将非终结符排序为：R、Q、S&#10;&gt;&#10;&gt; 2️⃣&#10;&gt; 对于R，不存在直接左递归，将R带入到Q的有关候选后，我们把Q的规则变为Q-&amp;gt;Sab|ab|b&#10;&gt;&#10;&gt; 现在的Q同样不含有直接左递归，把它带入到S的有关候选后，S变为S-&amp;gt;Sabc|abc|bc|c，消除S的直接左递归，可以得到整个文法&#10;&gt;&#10;&gt; S-&amp;gt;abcS'|bcS'|cS'&#10;&gt;&#10;&gt; S'-&amp;gt;abcS'|ε&#10;&gt;&#10;&gt; Q-&amp;gt;Sab|ab|b&#10;&gt;&#10;&gt; R-&amp;gt;Sa|a&#10;&gt;&#10;&gt; 其中Q和R的规则已经多余，化简以后可以得到&#10;&gt;&#10;&gt; S-&amp;gt;abcS'|bcS'|cS'&#10;&gt;&#10;&gt; S'-&amp;gt;abcS'|ε&#10;&gt;&#10;&gt; 由于排序不同，最后得到的文法在形式上可能不一样，但是都是等价的">
    </outline>
    <outline text="消除回溯、提左因子" _note="**回溯原因**&#10;&#10;&gt; 若当前符号 = a，对 A 展开，而 A -&amp;gt;&#10;&gt; α1|α2|...|αm那么，要知道哪一个αi是获得以a开头的串的唯一替换式。&#10;&gt;&#10;&gt; 即：选择哪一个αi，亦即通过查看第一个（当前）符号来发现合适的替换式α。&#10;&#10;**如何选择αi？**&#10;&#10;&gt; 以a为开头的αi&#10;&gt;&#10;&gt; 如果有多个αi以a开头，则这是文法的问题&#10;&#10;**举例**&#10;&#10;&gt; 有产生式&#10;&gt;&#10;&gt; 语句-&amp;gt;if 条件 then 语句 else 语句|while 条件 do 语句|begin 语句表&#10;&gt; end&#10;&gt;&#10;&gt; 若要寻找一个**语句**，那么关键字if，while，begin就提示我们哪一个替换式是最右可能成功的替换式&#10;&#10;若要求不得回溯，文法G（不含有左递归）的必要条件是什么？&#10;&#10;&gt; 若由$\\alpha\_i\\overset{+}{\\Rightarrow}a...$(某个文法符号串经过若干步推导可以得到以a（终结符）开头的串)，选该αi必中，但若$\\alpha\_j\\overset{+}{\\Rightarrow}a...$,,就会导致无法百发百中。解决办法是对文法本身提出要求:不要出现以上情况”。把上述要求阐明清楚可以采用如下定义的**FIRST(a),即a的首符集**。由于空串的存在，不能称为首终结符集。&#10;&gt;&#10;&gt; 首符集定义FIRST(α)&#10;&gt;&#10;&gt; $$FIRST(\\alpha)=\\{a|\\alpha\\overset{\*}{\\Rightarrow}a…，a\\in V\_T\\}\\\\&#10;&gt; if\\ \\alpha\\overset{\*}{\\Rightarrow}ε,define\\ ε\\in FIRST(\\alpha)$$&#10;&#10;**定理**&#10;&#10;&gt; 若一个*A* ∈ *V*_(*N*)有许多*F**I**R**S**T*(*α*_(*i*))。如果A的任何两个候选式*α*_(*i*)和*α*_(*j*)之间均满足&#10;&gt;&#10;&gt; $$FIRST(\\alpha\_i)\\cap FIRST(\\alpha\_j)=\\empty$$&#10;&gt;&#10;&gt; 意味着，A的每一候选式α推导后所得的字符串第一个*V*_(*T*)均不同。&#10;&gt;&#10;&gt; 于是，对输入符号α,如果α∈FIRST(αi), 则α not∈FIRST(αj),&#10;&gt; (j≠i)。因此，对A的展开无疑应选候选式αi,否则无法命中。&#10;&#10;**消除回溯目的**&#10;&#10;使非终结符A所有候选式的首符集两两不相交&#10;&#10;**方法：提取公共因子**&#10;&#10;&gt; 若：*A* −  &amp;gt; *δ**β*₁|*δ**β*₂|...|*δ**β*_(*n*)|*γ*₁|*γ*₂|...|*γ*_(*m*)，其中每个γ不以δ开头&#10;&gt;&#10;&gt; 那么可以把这些规则改写成&#10;&gt;&#10;&gt; $$A\\rightarrow \\delta A'|γ\_1|γ\_2|...|γ\_m\\\\&#10;&gt; A'\\rightarrow \\beta\_1|\\beta\_2|...|\\beta\_n$$">
    </outline>
  </outline>
  <outline text="递归下降分析程序构造" _note="在**不含左递归**和**每个非终结符的所有候选式的首符集都两两不相交**条件下，构造一个不带回溯的自上而下分析程序,该分析程序由一组递归过程组成，每个过程对应文法的一个非终结符。这样的一个分析程序称为递归下降分析器。&#10;&#10;**举例**&#10;&#10;&gt; 文法G:&#10;&gt;&#10;&gt; E-&amp;gt;TE'&#10;&gt;&#10;&gt; E'=&amp;gt;+TE'|ε&#10;&gt;&#10;&gt; T-&amp;gt;FT'&#10;&gt;&#10;&gt; T'-&amp;gt;\*FT'|ε&#10;&gt;&#10;&gt; F-&amp;gt;(E)|i&#10;&gt;&#10;&gt; 每个非终结符对应的递归子程序如下：&#10;&gt;&#10;&gt; 面临输入：i1+i2\*i3的分析步骤如下&#10;&gt;&#10;&gt; ![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220327223720153.png)&#10;&#10;构造语法树时，注意点&#10;&#10;&gt; 有ε，自动匹配，不会失败&#10;&gt;&#10;&gt; 无成功/失败消息返回&#10;&gt;&#10;&gt; 出错位置不确切&#10;&#10;构造递归下降分析程序时，它由一组递归过程组成。每个递归过程对应文法的一个**非终结符**。">
  </outline>
  <outline text="预测分析程序" _note="❓ 问题：  &#10;用递归子程序描写递归下降分析器，要求实现该编译程序的语言（高级或汇编）允许递归。&#10;&#10;🚗 改进：  &#10;使用一张分析表和一个栈同样可实现递归下降分析。用这种方法实现的语法分析程序叫**预测分析程序**。">
    <outline text="预测分析程序的工作过程" _note="![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220318105313920.png)&#10;&#10;预测分析表事先已经准备好了。">
      <outline text="预测分析程序有四部分" _note="&gt; 1️⃣ 一个输入:含有要分析的终结符串，右端有\#。&#10;&gt;&#10;&gt; 2️⃣ 一个栈:栈底是\#，栈内是一系列文法符号;开始时，\#和S先进栈。&#10;&gt;&#10;&gt; 3️⃣ 分析表:二维数组M\[A, a\],&#10;&gt; 其中*a* ∈ *V*_(*T*); *A* ∈ *V*_(*N*)，\#要占一列，多了一列&#10;&gt;&#10;&gt; 4️⃣ 输出:根据分析表内元素做规定的语法分析动作。">
      </outline>
      <outline text="分析程序的动作" _note="程序测定栈顶符号X和当前输入符号a,由(X, a)决定程序动作，三种可能:&#10;&#10;&gt; 1️⃣ 若X=a=\#，分析停止，宣告成功地完成分析;&#10;&gt;&#10;&gt; 2️⃣ 若X=a≠\#,则X弹出栈，前移输入指针;&#10;&gt;&#10;&gt; 3️⃣&#10;&gt; 若*X* ∈ *V*_(*N*),则去查分析表M的元素M\[X,a\],该元素或为X的产生式，或为一个出错元素。&#10;&gt;&#10;&gt; 对第3)条，*X* ∈ *V*_(*N*)，查分析表M的元素M\[X, a\]后&#10;&gt;&#10;&gt; &gt; 如:M\[X,a\]={X-&amp;gt;UVV},就用WVU(U在顶)替换栈顶的X;&#10;&gt; &gt;&#10;&gt; &gt; 如: M\[X, a\]=error,则调用error程序。">
      </outline>
      <outline text="分析表格式" _note="&gt; 文法G:&#10;&gt;&#10;&gt; E-&amp;gt;TE'&#10;&gt;&#10;&gt; E'=&amp;gt;+TE'|ε&#10;&gt;&#10;&gt; T-&amp;gt;FT'&#10;&gt;&#10;&gt; T'-&amp;gt;\*FT'|ε&#10;&gt;&#10;&gt; F-&amp;gt;(E)|i&#10;&#10;[TABLE]&#10;&#10;&gt; \#（界符）视为特殊的终结符&#10;&gt;&#10;&gt; 所有的行跟非终结符对应，所有的列跟终结符对应&#10;&gt;&#10;&gt; 隐去了出错处理">
      </outline>
      <outline text="举例说明" _note="按照预测分析程序，对于输入id+id\*id所作&#10;&#10;![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220327233422181.png)&#10;&#10;**结论**&#10;&#10;①输出的产生式就是最左推导的产生式。栈中放右部，等待与α匹配；&#10;&#10;②分析表中出现（栈顶，a）时，指出如何扩充树，并且能马上发现错误。&#10;&#10;**实质**&#10;&#10;&gt; 栈：残缺规范句型&#10;&gt;&#10;&gt; 表：指出*V*_(*N*)按哪一条扩充，依赖于*V*_(*T*)">
      </outline>
    </outline>
    <outline text="分析表的构造[考点]" _note="按照$\\alpha\\overset{\*}{\\Rightarrow}？$将产生式分成两种&#10;&#10;&gt; $\\alpha\\overset{\*}{\\Rightarrow}a……$&#10;&gt;&#10;&gt; $\\alpha\\overset{\*}{\\Rightarrow}ε$&#10;&#10;先要构造两个与G有关的集合：FIRST(α)首符集和FOLLOW(A)后继符集(跟在非终结符A后面的终结符)&#10;&#10;1️⃣ 定义：对于文法G，*α* ∈ *V*\*，S、A ∈ *V*_(*N*)&#10;&#10;$$\\begin{align}&#10;&amp;\\text{FIRST}(\\alpha)=\\{a|\\alpha\\overset{\*}{\\Rightarrow}a…,a\\in V\_T\\}\\\\&#10;&amp;若\\alpha\\overset{\*}{\\Rightarrow}ε，规定ε\\in FIRST(\\alpha)\\\\&#10;&amp;\\text{FOLLOW}(A)=\\{a|S\\overset{\*}{\\Rightarrow}\\alpha Aa\\beta ,a\\in V\_T,\\alpha, \\beta \\in V^\*\\}&#10;\\end{align}$$&#10;&#10;2️⃣ 构造FIRST(α)&#10;&#10;🍎&#10;对于单符号：**先构造*F**I**R**S**T*(*X*), *X* ∈ *V*_(*T*) ∪ *V*_(*N*)**&#10;&#10;连续应用以下规则，直到再无终结符或ε加入任一FIRST集为止&#10;&#10;&gt; ① 若*X* ∈ *V*_(*T*)，则FIRST(X)={X}&#10;&gt;&#10;&gt; ②&#10;&gt; 若*X* ∈ *V*_(*N*), *且**X* → *a**α*，则{a}∪FIRST(X)；若*X* ∈ *V*_(*N*), *且**X* → *ε*，则{ε}∪FIRST(X)&#10;&gt;&#10;&gt; ③&#10;&gt; 若*X* ∈ *V*_(*N*), *且**X* → *Y*…，*Y* ∈ *V*_(*N*)，则FIRST(Y)\\{ε}∪FIRST(X)；若*X* → *Y*₁*Y*₂…*Y*_(*k*)，*Y*₁, ..., *Y*_(*i* − 1) ∈ *V*_(*N*)是一个产生式，而且对于任何j，1 ≤ *j* ≤ *i* − 1，*F**I**R**S**T*(*Y*_(*j*))中都含有ε，即$Y\_1...Y\_{i-1}\\overset{\*}{\\Rightarrow}ε$,则把*F**I**R**S**T*(*Y*_(*i*))中的所有非ε元素加入到FIRST(X)中；如果所有的*F**I**R**S**T*(*Y*_(*j*))，*j* = 1, 2, ..., *k*都有ε，则把ε也加入FIRST(X)&#10;&#10;所有的非终结符最后都会变成终结符串&#10;&#10;🍎&#10;对于符号串：**再进而构造*F**I**R**S**T*(*X*₁*X*₂...*X*_(*n*))*即**F**I**R**S**T*(*α*)**&#10;&#10;&gt; ① *F**I**R**S**T*(*X*₁)的非ε**终结符**加入*F**I**R**S**T*(*α*)&#10;&gt;&#10;&gt; ②&#10;&gt; 若*ε* ∈ *F**I**R**S**T*(*X*₁),则*F**I**R**S**T*(*X*₂)的所有非ε终结符加入*F**I**R**S**T*(*α*)&#10;&gt;&#10;&gt; ③&#10;&gt; 若*ε* ∈ *F**I**R**S**T*(*X*₁)，*ε* ∈ *F**I**R**S**T*(*X*₂),则*F**I**R**S**T*(*X*₃)的所有非ε终结符加入*F**I**R**S**T*(*α*)&#10;&gt;&#10;&gt; 最后，若*ε* ∈ *F**I**R**S**T*(*X*_(*i*)), *i* = 1, ..., *n*，则{ε}加入*F**I**R**S**T*(*α*)&#10;&#10;**终结符、非终结符、文法符号串、候选式都可以构造首符集；后继符集只能用终结符定义！**&#10;&#10;3️⃣ 构造FOLLOW(A)&#10;&#10;对于文法G的每个非终结符A构造FOLLOW(A)的办法是，连续使用下面的规则，直到每个FOLLOW不再增大为止&#10;&#10;&gt; ① 对于文法的开始符号S，置\#于FOLLOW(S)中——\#不能忽视！&#10;&gt;&#10;&gt; ② 若*A* → *α**B**β*，则把FIRST(β)\\{ε}加入到FOLLOW(B)中&#10;&gt;&#10;&gt; ③&#10;&gt; 若有*A* → *α**B*。或者*A* → *α**B**β*是一个产生式而*B* ⇒ *ε*(即ε∈FIRST(β))，则把FOLLOW(A)加入到FOLLOW(B)中">
      <outline text="✅举例1✅" _note="已知文法G:  &#10;E-&amp;gt;TE' T'-&amp;gt;\*FT'|ε E'-&amp;gt;+TE'|ε F-&amp;gt;(E)|i T-&amp;gt;FT'  &#10;求它的FIRST(α)，FOLLOW(A)&#10;&#10;&gt; 1️⃣ 构造首符集&#10;&gt;&#10;&gt; 首先看产生式右边，如果第一个符号是终结符，则把其加入非终结符的首符集中，再看一下候选式中有没有ε，有的话也加入首符集中，如由F-&amp;gt;(E)|i可知*F**I**R**S**T*(*F*) = {(,*i*}&#10;&gt;&#10;&gt; 还有一些推到关系，如T-&amp;gt;FT',E-&amp;gt;TE'，则F首符集中非ε的元素也是T中首符集的元素,T首符集中非ε的元素也是E中首符集的元素:FIRST(F)={&#10;&gt; ( , i }=FIRST(T)=FIRST(E)&#10;&gt;&#10;&gt; 2️⃣ 构造非终后继符集&#10;&gt;&#10;&gt; 由法则①：FOLLOW(E)={\#}&#10;&gt;&#10;&gt; 由法则②&#10;&gt;&#10;&gt; E-&amp;gt;TE'，则将 FIRST(E') \\ {ε} 加入 FOLLOW(T)：FOLLOW(T)={+}&#10;&gt;&#10;&gt; T-&amp;gt;FT'，则将 FIRST(T') \\ {ε} 加入 FOLLOW(F)：FOLLOW(F)={\*}&#10;&gt;&#10;&gt; F-&amp;gt;(E)，则将FIRST( **)** )加入FOLLOW(E)：FOLLOW(E)={ \# , ) }&#10;&gt;&#10;&gt; &gt; 由FISRT①，FIRST( **)** )=）&#10;&gt;&#10;&gt; 由法则③&#10;&gt;&#10;&gt; E-&amp;gt;TE'，将FOLLOW(E)加入到FOLLOW(E')中:FOLLOW(E')={ ) , \#}}&#10;&gt;&#10;&gt; E-&amp;gt;TE'，且E'-&amp;gt;ε，则将FOLLOW(E)加入到FOLLOW(T)中：FOLLOW(T)={ + ,&#10;&gt; ) , \#}&#10;&gt;&#10;&gt; T-&amp;gt;FT'，将FOLLOW(T)加入到FOLLOW(T')中：FOLLOW(T')={ + , ) , \#}&#10;&gt;&#10;&gt; T-&amp;gt;FT'，且T'-&amp;gt;ε，将FOLLOW(T)加入到FOLLOW(F)中：FOLLOW(F)={\*, +&#10;&gt; , ) , \#}&#10;&#10;[TABLE]&#10;&#10;4️⃣ **分析表的构造**&#10;&#10;算法：输入：G1文法，输出：分析表M&#10;&#10;&gt; ① 对文法的每一个A-&amp;gt;α，做②和③&#10;&gt;&#10;&gt; ② 对于任一a∈FIRST(α)，把A-&amp;gt;α加入到M\[A，a\]（可能不止一个）&#10;&gt;&#10;&gt; ③&#10;&gt; 若ε∈FIRST(α)，则把A-&amp;gt;α加入M\[A，b\]，b∈FOLLOW(A)；若ε∈FIRST(α)，\#∈FOLLOW(A)，则把A-&amp;gt;α加进M\[A,\#\]&#10;&gt;&#10;&gt; ④ 把所有无定义的M\[A，a\]标上“出错标志”">
      </outline>
      <outline text="✅举例2✅" _note="将算法应用于上述文法G：E-&amp;gt;TE' T'-&amp;gt;\*FT'|ε E'-&amp;gt;+TE'|ε&#10;F-&amp;gt;(E)|i T-&amp;gt;FT'&#10;&#10;① E-&amp;gt;TE'&#10;&#10;因为FIRST(TE')=FIRST(T)={(,i)}，即产生式E-&amp;gt;TE'保证了M\[E，i\]和M\[E,&#10;(\]中持有E-&amp;gt;TE'&#10;&#10;所以M\[E，(\]={E-&amp;gt;TE'} M\[E，id\]={E-&amp;gt;TE'}&#10;&#10;② E'-&amp;gt;+TE'&#10;&#10;因为FIRST(+TE')={+}，所以M\[E'，+\]={E'-&amp;gt;+TE'}&#10;&#10;③ E'-&amp;gt;ε&#10;&#10;因为有ε，需要去看产生式的左部非终结符的FOLLOW集中有哪些终结符&#10;&#10;FOLLOW(E')={),\#}，所以M\[E',)\]={E'-&amp;gt;ε}，M\[E'，\#\]={E'-&amp;gt;ε}&#10;&#10;最终可以得到如下分析表&#10;&#10;[TABLE]&#10;&#10;上述算法可应用于任何文法G以构造它的分析表M。但对于某些文法，有些M\[A,a\]可能持有若干个产生式，或者说有些M\[A,a\]可能是多重定义的。如果G是左递归或二义的，那么，M至少含有一个多重定义人口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表M。&#10;&#10;**可以证明，一个文法G的预测分析表M不含多重定义入口，当且仅当该文法为LL(1)的。**">
      </outline>
    </outline>
  </outline>
  <outline text="LL(1)文法" _note="LL：第一个L表示从左到右扫描输入串；第二个L表示最左推导&#10;&#10;(1)：表示分析时每一步只需要向前查看一个符号">
    <outline text="LL(1)文法" _note="一个文法G，若它的分析表M不含多重定义入口(**同一个格子里面有两个产生式**)，则称它为一个LL(1)文法">
    </outline>
    <outline text="LL(1)文法的条件" _note="文法G式LL(1)的，则对于G的每一个非终结符A的任何两个不同产生式A-&amp;gt;α|β，有：&#10;&#10;&gt; 1️⃣ FIRST(α)∩FIRST(β)=Φ&#10;&gt;&#10;&gt; 2️⃣&#10;&gt; 若某一个候选式$\\beta\\mathop\\Rightarrow\\limits ^\* ε$，则FIRST(α)∩FOLLOW(A)=Φ&#10;&#10;🍌 **说明**&#10;&#10;**使用LL(1)文法，一定可以实现不带回溯的自上而下分析**&#10;&#10;若某文法G为LL（1)文法，则下列那些描述正确？&#10;&#10;&gt; ✅该文法的预测分析表必无多重入口。&#10;&gt;&#10;&gt; ✅所有非终结符各候选式的首符集两两之间交集必为空。&#10;&gt;&#10;&gt; ✅非终结符的某个候选式的首符集中有空串时，该非终结符的后继符集与其余各个候选式首符集交集必为空。&#10;&#10;**但是，条件语句文法不能改造成LL(1)文法**&#10;&#10;语句-&amp;gt;if 条件 then 语句 else 语句|if 条件 then 语句&#10;&#10;例如：S-&amp;gt;iCtS|iCtSeS|a C-&amp;gt;b&#10;&#10;&gt; 提公因子以后，文法变为S-&amp;gt;iCtSS'|a S'-&amp;gt;eS|ε C-&amp;gt;b&#10;&gt;&#10;&gt; 计算该文法的FIRST集和FOLLOW集如下：&#10;&gt;&#10;&gt; FIRST(S)={i，a} FIRST(S')={e，ε} FIRST(C)={b}&#10;&gt;&#10;&gt; FOLLOW(S)={\#，e} FOLLOW(S')={\#，e} FOLLOW(C)={t}&#10;&gt;&#10;&gt; 分析表如下：&#10;&gt;&#10;&gt; [TABLE]&#10;&gt;&#10;&gt; 上表未填满&#10;&gt;&#10;&gt; 对于候选式S'-&amp;gt;ε，因为ε∈FIRST(S')={e，ε}，而FOLLOW(S')={\#，e}，所以S'-&amp;gt;ε填入M\[S',\#\]和M\[S'，e\]，**有多重入口，不是LL(1)文法**&#10;&gt;&#10;&gt; 解决：**强制令**M\[S'，e\]={S'-&amp;gt;eS}，即坚持将e与最近的t相结合，从程序语言来看，相当于规定ELSE坚持与最近的THEN相结合">
    </outline>
  </outline>
  <outline text="参考资料" _note="\[1\] 西安交通大学软件工程专业编译原理 吴晓军 2022春&#10;&#10;\[2\] 陈火旺，刘春林，谭庆平，赵克佳，刘越.&#10;程序设计语言编译原理（第3版）. 北京：国防工业出版社，2010">
  </outline>
</outline>
  </body>
</opml>
