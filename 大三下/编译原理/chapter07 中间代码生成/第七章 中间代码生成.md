[TOC]

# 第七章 语义分析和中间代码生成

词法分析和语法分析之后的中间代码产生是编译第三阶段的工作。本章介绍几种典型的中间代码形式以及产生它们的算法

中间代码的形式很多，如逆波兰记号、树形表示、三元式、四元式。他们都是**介于单词流与目标指令之间的"中间产品"**

**困难**

> 目前还不存在一种广泛接受的方式来描述为典型程序语言产生中间代码所需的语义动作。原因是代码生成依赖于对语义的解释，而语义刻画的形式化系统尚未诞生。

**解决办法**

> 为每一个产生式配一个**翻译子程序**（语义子程序、动作)，在语法分析的同时执行它。这样配上语义动作之后，既指定了串的意义，同时又按这种意义规定了产生某种**中间代码应作的基本动作**

## 回顾

### 语法制导翻译

**概念**：在语法分析过程中，随着分析的步步进展，根据每个产生式所对应的**语义子程序**（语义动作）进行翻译（**产生中间代码**）的办法。

**标记说明**

> 描述语义动作时，需要赋予每个文法符号X(终结符或者非终结符)以种种不同方面的**值**，如X.type(类型)，X.val(值)等。
>
> 一个产生式中同一个符号多次出现，用下标来区分
>
> > 例如：$E\rightarrow E+E$表示为$E\rightarrow E_1+E_2$
>
> 每个产生式的**语义动作**，写在该产生式的花括号内

**语法制导的一个具体实现**

先对LR分析器的栈做一些改进，加入语义值

![image-20220421234740823](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220421234740823.png)

**文法（进行了拓广）及其语义动作（加在了产生式末尾）**

![image-20220421234812349](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220421234812349.png)

上述的语义动作等于给出了计算由十、*组成的整数算术式的过程。其相应的程序段如下

![image-20220421234935852](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220421234935852.png)

若把语义动作改为产生中间代码的动作，就能随着分析的进展逐步产生中间代码

## 7.1 中间语言

中间代码的必要性

> 大部分的编译器都不直接产生目标代码，虽然这是可以实现的，但是产生的代码**不是最优的**，因
> 为这涉及到**寄存器的分配问题**。在语义分析阶段：很难有效地分配它们。

### 7.1.1 逆波兰表示法（后缀式）

波兰逻辑学家卢卡西维奇(Lukasiewicz)发明的一种表示法。

#### 概念

> 一般，若e1,e2为任意的后缀表达式，Θ为任意双目运算符，则Θ作用于e1和e2所代表的结果
> 用后缀式e1e2Θ表示。
>
> 推而广之，Θ为k目运算符，则Θ作用于e1e2…ek的结果用e1e2…ekΘ来表示。

#### 实例

> $a*(b+c)\rightarrow abc+*$
>
> $(a+b)*(c+d)\rightarrow ab+cd+*$
>
> 若用？表示if-then-else，则
>
> if a then if c-d then a+c else a\*c else a+b -> a cd- ac+ ac* ? ab+ ?
>
> 其中cd- ac+ ac* ?为内部语句

#### 后缀式求值

使用一个栈（软件栈或者硬件栈）来求值。

求值过程：

> **从左到右扫描后缀式，每碰到运算量就把它推进栈，每碰到k目运算符就把它作用于栈顶的k个项，并用运算结果来代替这k个项**

#### 控制流的后缀式

前面讲到，if-then-else运算符的实现“exy?”-> e不等于0(为真)，取x,否则取y.

这种表示法要求在任何情况下都要把x,y都计算出来，尽管只用到其中一个。

**如果运算量无定义或者有副作用（x和y是互斥的，但是都要算，就会出错），则后缀表示法不仅无效，而且可能是错误的。**

**解决办法**

> 引入标号，在后缀式中加入**条件转移、无条件转移算符**

**存储方式**：后缀式存放在一维数组POST[1…N]中，每个元素是运算符或者分量（指向符号表）

**转移算符**

> p jump -> 转到POST[P]   :label: 无条件的
>
> e1 e2  p jlt(jump when less then) -> e1<e2时，转到POST[p]
>
> e p jez(jump when equal to zero) -> 若e=0，转到POST[p]

> if e then x else y -> e p1 jez x p2 jump p1:y  p2:
>
> 在数组POST中出现的后缀式为
>
> ![image-20220422001439263](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422001439263.png)

#### 语法制导生成后缀式

产生式所带的语义动作，由以下翻译模式描述。

![image-20220422001652728](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422001652728.png)

![image-20220422002255924](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422002255924.png)

### 7.1.2 树

用树形结构来表示一个表达式或者语句。

简单变量或者常数的树就是该变量或者常数自身。一般地，叶子表示运算量，内部结点
表示OP。例如，已知e1和e2的树为T1和T2,则e1+e2、e*e,和-e1的树分别为：

![image-20220422002459447](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422002459447.png)

例 A*(B+C)/D

右边的是抽象语法树

![image-20220422002622389](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422002622389.png)



**语法制导产生树**![image-20220422002643016](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422002643016.png)

![image-20220422002716522](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422002716522.png)

### 7.1.3 三地址代码

#### 三元式

> 三元式的构成：$OP\  ARG_1\  ARG2$
>
> $ARG_1$和$ARG_2$都是指示器，或者指向符号表的某项，或者是三元式表自身的某项。OP通常用**整数编码**
>
> X := A + B * C的三元式
>
> :one: * B C
>
> :two: + A :one:
>
> :three: := X :two: 

语法制导生成三元式的语义动作

![image-20220422103219611](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422103219611.png)

> 其中，E.VAL是**指示器**，指向符号表中的某一项，或者三元式表中的某一项
>
> TRIP是一个**语义过程**，产生一个新的三元式，回送新三元式在三元式表中的位置
>
> ENTRY是一个**函数过程**，在符号表中查找id代表的标识符以获知它在表中的位置

**两个语义过程**

> **LOOKUP(NAME)**：在符号表中查NAME,如果查到则返回入口值，否则返回NULL。(出错处理，调用FILLSYM）
>
> **FILLSYM(NAME)**：在符号表中开辟新项目，并返回入口值。

**问题**

> 三元式指示器连接，不易更改，不利于优化

#### 间接三元式

所以引入间接三元式：用一张**间接码表**辅助三元式来表示中间代码

间接码表体现了顺序。**在进行代码优化时，如果需要调整顺序，只需要重新安排间接码表而无需改动三元式表**。同时，相同的三元式无需重复填入三元式表

对于间接三元式表示，产生三元式表时，应增添产生间接码表的语义动作。并且，在向三元式表填进一个三元式之前，必须先查看一下此式是否已在其中，如已在其中则不必再填入。 ![image-20220422104737181](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220422104737181.png)

#### 四元式

$OP\  ARG_1\  ARG_2\ RESULT$

OP：算符的整数码
ARG和RESULT：符号表入口或者临时变量的整数码
RESULT为$T_i$：时的处理：可以填入符号表，通过符号表入口进行用
也可以不填，用某种整数编码代表它们。

运算量和运算结果有时指用户自定义的变量，有时指编译程序引进的**临时变量**。如果OP是算术或者逻辑算符，则RESULTA总是一个新引进的临时变量，用于存放中间结果。注意，可以不加限制地使用临时变量，在优化时再进行压缩

## 7.3 赋值语句的翻译

### 7.3.1 简单算术表达式以及赋值语句

### 7.3.2 数组元素引用的翻译

## 7.4 布尔表达式的翻译

布尔表达式是用布尔运算符号(and,or,not)作用到布尔变量或关系表达式上而组成的。关系表达式形如$E_1\ \text{relop} \ E_2$，其中$E_1$和$E_2$是算术表达式，elop为关系运算符(<，≤，=，≠，>，≥）

文法表示如下：
$$
E\rightarrow E\or E|E\and E|\neg E|(E)|i \ \text{rop}\ i|i
$$
布尔算符的优先顺序：$\neg,\and,\or$

$\and、\or$服从左结合

所有**关系算符的优先级相同**，高于任何布尔算符，低于任何算术算符

$算术算符>关系算符>布尔算符$

布尔表达式E在语言中的用途：

> 计算逻辑值	$X:=A\or B<D$
>
> 条件表达式	WHILE $A\or B<D$	DO	S
>
> ​					 IF $A\or B<D$	THEN	S1	ELSE	S2

布尔表达式的求值

> :one: 一种办法是，如同计算算术表达式一样，一步不差地从表达式各部分的值计算出整个表达式的值。
>
> 例如，按通常的习惯，用数值1代表 tnue,用0代表false.$A\or B\and C=D$翻译为
>
> =	C	 D	 T1
>
> $\and$	B	T1	T2
>
> $\or$	A	T2	T3
>
> :two: 另一种计算法是采取某种优化措施。
>
> 例如，假定要计算A or B,如果计算出A的值为 1,那么，B的值就无须再计算了。因为不管B的结果是什么，A or B的值都为1。同理，在 计算A and B 时，若发现A为0，则B的值也就无需再计算了。这种计算法意味着，我们可 以用if-then-else来解释or,and和not。也就是
>
> - 把AorB解释成	        if A then true else B
> - 把A and B解释成	   if A then B else false
> - 把notA解释成			if A then false else true

上述这两种计算法对于不包含布尔函数调用的式子是没有什么差别的。但是，假若一个布尔式中含有布尔函数调用，并且这种函数调用引起副作用（指对全局量的赋值）时，那么，上述两种计算法**未必是等价**的。有些程序语言规定，函数过程调用应不影响这个调用所处环境的计值。或者说，函数过程的工作不许产生副作用。在这种规定下，我们可以任选上述的一种方法。

下面我们将分别用这两种方法来讨论如何把布尔表达式翻译成地址代码。

### IF语句的四元式结构

条件语句if E then S1 else S2，赋予E两个出口：——真——假



### 翻译的困难和解决办法

#### 困难

转移的目标在对它的引用之后才出现：(j，_, _, 0)

条件表达式E可以很复杂，上面的情况

#### 解决办法

凡是先有

### E的文法和语义子程序

### 举例

用自下而上语法分析方法，语法制导翻译生成$(A\and B)\or \neg C$的四元式

不管多复杂，布尔表达式四元式只有两个出口（第四元为0）

## 7.5 控制语句的翻译

常用的控制语句

- $S\rightarrow \text{if}\ E \ \text{then} \ S_1$
- $S\rightarrow \text{if}\ E \ \text{then} \ S_1\ \text{else} \ S_2$
- $S\rightarrow \text{while}\ E \ \text{do} \ S_1$

其中E为布尔表达式

### 7.5.1 控制流语句

较为复杂的程序控制语句常常是嵌套的

考试的时候一定是嵌套的

文法
$$
\begin{align}
&(1)\ S\rightarrow\ \text{if}\ E\ \text{then} \ S\\
&(2)\qquad \ \ |\text{if} \ E\ \text{then}\ S \ \text{then}\ \text{else}\ S\\
&(3)\qquad \ \ |\text{while}\ E \ \text{do}\ S\\
&(4)\qquad \ \ |\text{begin}\ L \ \text{end}\\
&(5)\qquad \ \ |A\\
&(6)L\rightarrow L;S\\
&(7)\qquad \ \ |S

\end{align}
$$
语义动作

> S  →  if   E   then   M   S1
> 	{backpatch (E.truelist，M.quad);
> 	 s
> 	 S.nextlist:=merge(S1)

### 7.5.2 标号与goto语句

标号的两种使用方法

> L:	S
>
> Goto	L

语言中允许标号先定义后使用，也允许先使用后定义

