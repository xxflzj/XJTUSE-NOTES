<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="第三章 上下文无关文法" _note="目的：&#10;&#10;&gt; 对语言的语法结构进行形式描述&#10;&gt;&#10;&gt; 从形式描述中，研究语法分析器的构造（分析法递归子程序和算符优先分析法）">
  <outline text="3.1 引言" _note="**文法**：是描述语言的语法结构的形式规则（即语法规则），是为了解决语言的有穷说明问题，包含对语法的描述，但是不表达任何语义&#10;&#10;**文法的描述应该达到以下要求**：形式上严格，准确；易于理解；描述能力强；有利于句子的分析和翻译，构造语法分析器&#10;&#10;**文法的分类**：分为四类(0,1,2,3型文法)；与程序语言语法有关的是上下文无关文法&#10;&#10;上下文无关文法的特点：它所定义的语法范畴（或语法单位）完全独立于这种范畴可能出现的环境。&#10;&#10;&gt; 上写文无关文法只能描述一部分语言，但是已经足够描述现今的程序设计语言&#10;&gt;&#10;&gt; 自然语言要用别的描述方法">
  </outline>
  <outline text="3.2 文法与语言">
    <outline text="定义" _note="一个上下文无关文法G是一个四元式(*V*_(*T*), *V*_(*N*), *S*, *P*)&#10;&#10;&gt; *V*_(*N*)：是非空有限集合，它的每个元素是非终结符号&#10;&gt;&#10;&gt; *V*_(*T*)：是非空有限集合，它的每个元素是终结符号&#10;&gt;&#10;&gt; $V\_N\\cap V\_N=\\empty\\qquad V\_T\\cup V\_N=V$&#10;&gt;&#10;&gt; *S*：*S* ∈ *V*_(*N*)，称为开始符号（相当于有限自动机的初态）&#10;&gt;&#10;&gt; 𝒫：产生式集合（有限），每个产生式是&#10;&gt;&#10;&gt; {*P* → *α*|*P* ∈ *V*_(*N*), *α* ∈ (*V*_(*T*) ∪ *V*_(*N*))^(\*), *S**至**少**一**次**为**P*},S即要在左边至少出现一次&#10;&gt;&#10;&gt; “→&quot; 相当于*i**s* *d**e**f**i**n**e**d* *a**s*&#10;&#10;**举例**：考虑以下算数表达式的文法以及语言&#10;&#10;&gt; *V*_(*T*)： id + - \* / ↑ ( )  &#10;&gt; *V*_(*N*)：表达式、运算符  &#10;&gt; *S*： 表达式  &#10;&gt; 𝒫： 表达式-&amp;gt;表达式 运算符 表达式  &#10;&gt; 表达式-&amp;gt;（表达式）  &#10;&gt; 表达式-&amp;gt;— 表达式  &#10;&gt; 表达式-&amp;gt; id  &#10;&gt; 运算符-&amp;gt;+|-|\*|/|↑&#10;&gt;&#10;&gt; 得到文法G1(E) : E-&amp;gt;EAE|(E)|-E|id A-&amp;gt;+|-|\*|/|↑&#10;&gt;&#10;&gt; 由此可见，文法G1(E)所定义的语言是算术表达式，如id+id,id\*(id+id)等&#10;&gt;&#10;&gt; 它表达了简单算术表达式由id用A连接起来&#10;&gt;&#10;&gt; 该文法的:&#10;&gt;&#10;&gt; 1️⃣ *V*_(*N*)是出现在P的左部所有符号集合&#10;&gt;&#10;&gt; 2️⃣ V是𝒫的所有符号：*V*_(*T*) = *V*/*V*_(*N*)&#10;&gt;&#10;&gt; 3️⃣ S是该文法所定义的句子名字&#10;&gt;&#10;&gt; 4️⃣ 写出了𝒫，就能找出其它三元素">
    </outline>
    <outline text="各个符号的意义" _note="1️⃣&#10;**终结符**：是用以组成语言中的串的基本符号，与程序语言中的“单词”是同义语&#10;&#10;如表达式 *i**d* + (*i**d*)^(\*)( − *i**d*)中，+、-、\*、/、id均为终结符&#10;&#10;2️⃣&#10;**非终结符**：非终结符号(也称语法变量)用来代表语法范畴。例如,“算术表达式”“布尔表达式”“赋值句”“分程序”“过程”等,它们都是现今程序语言常见的语法范畴。我们也可以说，一个非终结符代表一个一定的语法概念。因此，一个非终结符是一个类(或集合)记号,而不是一个个体记号。例如，算术表达式&quot;这个非终结符乃代表一定算术式组成的类。因而,也可以说,每个非终结符号表示一定符号串的集合(由终结号和非终结符号组成的符号串）。&#10;&#10;3️⃣&#10;**开始符号**：一个特殊的非终结符，标记最终感兴趣的语法范畴（句子），其他非终结符用以定义其他的串集，这有助于定义该语言，也有助于为它处理的语言提供一个分层的结构&#10;&#10;4️⃣ **产生式**：规定由终结符和别的语法范畴组成一个新的语法范畴的办法&#10;&#10;&gt; 结构：非终结符-&amp;gt;一串非终结符和终结符&#10;&gt;&#10;&gt; &gt; 如：A-&amp;gt;α，A是左部符号*V*_(*N*)，α是右部候选式，*α* = *X*₁*X*₂*X*₃...*X*_(*N*), *X*_(*i*) ∈ *V*&#10;&#10;**举例**&#10;&#10;&gt; 语法规则如下：&#10;&gt;&#10;&gt; &amp;lt;句子&amp;gt; → &amp;lt;主语&amp;gt; &amp;lt;谓语&amp;gt; &amp;lt;间接宾语&amp;gt;&#10;&gt; &amp;lt;直接宾语&amp;gt;  &#10;&gt; &amp;lt;主语&amp;gt; → &amp;lt;代词&amp;gt;  &#10;&gt; &amp;lt;谓语&amp;gt; → &amp;lt;动词&amp;gt;  &#10;&gt; &amp;lt;间接宾语&amp;gt; → &amp;lt;代词&amp;gt;  &#10;&gt; &amp;lt;直接宾语&amp;gt; → &amp;lt;冠词&amp;gt; &amp;lt; 名词&amp;gt;  &#10;&gt; &amp;lt;代词&amp;gt; → He  &#10;&gt; &amp;lt;代词&amp;gt; → me  &#10;&gt; &amp;lt;名词&amp;gt; → book  &#10;&gt; &amp;lt;冠词&amp;gt; → a  &#10;&gt; &amp;lt;动词&amp;gt; → gave&#10;&gt;&#10;&gt; 比如He gave me a book是一个语法正确的句子&#10;&gt;&#10;&gt; 👉 该语法范畴叫&quot;**句子**&quot;，在程序语言中叫“ **程序**”&#10;&gt;&#10;&gt; 👉 语言的句子是由一串*V*_(*N*)定义，到最后才是一串*V*_(*T*)">
    </outline>
    <outline text="习惯记号" _note="*V*_(*N*)：大写字母A、B、C、S等&#10;&#10;*V*_(*T*)：小写字母，0~9，+，-等运算符，标点，分界符，黑体字母串，id，if&#10;&#10;X、Y、Z：文法符号，或*V*_(*N*)或*V*_(*T*)一个符号&#10;&#10;u、v、w……z：*V*_(*T*)中的串&#10;&#10;α、β、γ：文法符号串 ∈ (*V*_(*T*) ∪ *V*_(*N*))^(\*)&#10;&#10;S：开始符号，第一个产生式中出现&#10;&#10;-&amp;gt;：定义为(元语言符号)&#10;&#10;|：或(元语言符号)">
    </outline>
    <outline text="推导与语言" _note="❓ 问题：用文法如何定义一个语言？&#10;&#10;思路：从S出发，反复使用𝒫，对非终结符**替换**展开，最后得到全部由终结符串组成的一个串&#10;&#10;涉及到：**替换、推导、句型、句子、语言**&#10;&#10;1️⃣ **直接推出**：是两个**文法符号串**之间的一种关系ℛ&#10;&#10;如：(*α* *A* *β*) ℛ (*α* *γ* *β*)&#10;&#10;它表示，若*A* → *γ* ∈ 𝒫, *α*, *β* ∈ *V*^(\*)，则ℛ就是直接推出，ℛ记作⇒&#10;&#10;则有：(*α* *A* *β*)  ⇒ (*α* *γ* *β*)&#10;&#10;------------------------------------------------------------------------&#10;&#10;2️⃣ **推导**：如果两个串*u*₀, *u*_(*n*)，存在一个串序列&#10;&#10;*u*₀ ⇒ *u*₁ ⇒ ... ⇒ *u*_(*n*)&#10;&#10;则$u\_0\\ \\mathscr{R}\_1\\ u\_n\\quad \\mathscr{R}\_1记作\\mathop\\Rightarrow\\limits ^+或\\mathop\\Rightarrow\\limits ^\*$&#10;&#10;+：至少一步推导。\*：可以0步推导&#10;&#10;------------------------------------------------------------------------&#10;&#10;3️⃣ **如何从推导引出语言**&#10;&#10;$u\_0\\mathop\\Rightarrow\\limits ^+ u\_n$&#10;$u\_0\\mathop\\Rightarrow\\limits ^\* u\_n$&#10;&#10;🌵如果令*u*₀为S，即推导要从开始符号开始，那么$S\\mathop\\Rightarrow\\limits ^\* \\alpha,\\alpha\\in V^\*$，则称α为G的句型&#10;&#10;🌵 如果再要求*α* ∈ *V*_(*T*)^(\*)，则称*α*为G的句子&#10;&#10;🌵 文法G产生的句子的全体是一个语言，记作L(G)&#10;&#10;$$L(G)=\\{\\alpha |S \\mathop\\Rightarrow\\limits ^+ \\alpha \\ \\&amp;\\ \\alpha \\in V\_T ^\*\\}$$&#10;&#10;**说明**&#10;&#10;&gt; ①&#10;&gt; 由文法G定义语言L需依赖一种运算，即关系$\\mathop\\Rightarrow\\limits ^+$&#10;&gt;&#10;&gt; 当V\*中有许多串，只有那些(S, u)&#10;&gt; (S,v)存在$\\mathop\\Rightarrow\\limits ^+$关系的u,v才是语言中的**句子**。&#10;&gt;&#10;&gt; ② α , β是**句型**，表示(S， α) (S，&#10;&gt; β)有$\\mathop\\Rightarrow\\limits ^\*$的关系，但它们的构成是不全属于*V*^(*T*)的字符。&#10;&gt;&#10;&gt; ③&#10;&gt; G的**句型集**，是指存在$S\\mathop\\Rightarrow\\limits ^\* \\alpha$关系的所有α,该集的子集是L(G)。&#10;&gt;&#10;&gt; ④*L*(*G*) ⊂ *句**型**集* ⊂ *V*^(\*)&#10;&#10;**题目**&#10;&#10;&gt; 关于句型、句型集、句子、语言等概念，下面哪些说法是不正确的?&#10;&gt;&#10;&gt; A 终结符串是句子（句子是终结符串）&#10;&gt;&#10;&gt; B 终结符与非终结符的混合串是句型&#10;&gt;&#10;&gt; C 终结符集合的闭包是语言&#10;&gt;&#10;&gt; D 全体符合集合的闭包是甸句集&#10;&gt;&#10;&gt; ABCD&#10;&#10;**举例**：根据文法G：&#10;E-&amp;gt;E+E|E\*E|(E)|i，句子*i*₁ \* (*i*₂ + *i*₃)的推导过程如下&#10;&#10;&gt; 1️⃣&#10;&gt; *E* =  &amp;gt; *E* \* *E* =  &amp;gt; *i*₁ \* *E* =  &amp;gt; *i*₁(*E*) =  &amp;gt; *i*₁ \* (*E* + *E*) =  &amp;gt; *i*₁ \* (*i*₂ + *E*) =  &amp;gt; *i*₁ \* (*i*₂ + *i*₃)&#10;&gt;&#10;&gt; 最左推导&#10;&gt;&#10;&gt; 2️⃣&#10;&gt; *E* =  &amp;gt; *E* \* *E* =  &amp;gt; *E* \* (*E*) =  &amp;gt; *E* \* (*E* + *E*) =  &amp;gt; *E* \* (*E* + *i*₃) =  &amp;gt; *E* \* (*i*₂ + *i*₃) =  &amp;gt; *i*₁ \* (*i*₂ + *i*₃)&#10;&gt;&#10;&gt; 最右推导&#10;&#10;从一个句型到另一个句型的推导过程并不唯一，但是通常只考虑最左推导和最右推导&#10;&#10;&gt; 最左推导是指，任何一步a=&amp;gt; β都是对a中的最左非终结符进行替换。&#10;&gt;&#10;&gt; 最右推导是指，任何一步a=&amp;gt; β都是对a中的最右非终结符进行替换。">
    </outline>
  </outline>
  <outline text="3.3 语法树与二义性">
    <outline text="语法树" _note="**目的**：为了理解句子的语法，即理解句子如何从开始符号推导得到，因此引入“图”。&#10;&#10;**定义**：句型推导的图形表示，与**替换顺序的选取**无关。&#10;&#10;**作用**：明显地形成文法所暗含句子的分层语法结构，为语法分析提供一些新的途径。&#10;&#10;**树的内结点**：非终结符A标记，若A-&amp;gt;XYZ，则该产生式的一棵子树为&#10;&#10;![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220315174336689.png)&#10;&#10;**语法树与文法概念的对应关系如下**&#10;&#10;[TABLE]&#10;&#10;有的文法，对于同一句子，应用不同规则进行推导得到不同的语法树&#10;&#10;&gt; 没有区分优先级&#10;&#10;**举例** $E\\mathop\\Rightarrow\\limits^+ -(id+id)$的语法树&#10;&#10;&gt; 最左推导：E=&amp;gt;-E=&amp;gt;-(E)=&amp;gt;- (E+E) =&amp;gt;-(id+E) =&amp;gt;- (id+id)  &#10;&gt; 最右推导：E=&amp;gt;-E=&amp;gt;-(E) =&amp;gt;- (E+E) =&amp;gt;-(E+id)=&amp;gt;- (id+id)&#10;&gt;&#10;&gt; ![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220315205033733.png)&#10;&gt;&#10;&gt; 每一个中间过程，句型很容易获取&#10;&gt;&#10;&gt; 树忽略了符号的替换顺序的不同，不同的推导过程得到相同的语法树&#10;&gt;&#10;&gt; 有的文法，对于同一句子，应用不同规则进行推导会得到不同的语法树&#10;&#10;**举例：根据文法G对句子id+id\*id进行推导**&#10;&#10;&gt; 文法G：E-&amp;gt;E+E|E\*E|(E)|i&#10;&gt;&#10;&gt; 推导1&#10;&gt;&#10;&gt; E=&amp;gt;E+E=&amp;gt;id+E=&amp;gt;id+E\*E=&amp;gt;id+id\*E=&amp;gt;id+id\*id&#10;&gt;&#10;&gt; 推导2&#10;&gt;&#10;&gt; E=&amp;gt;E\*E=&amp;gt;E+E\*E=&amp;gt;id+E\*E=&amp;gt;id+id\*E=&amp;gt;id+id\*id&#10;&gt;&#10;&gt; ![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220315205919198.png)">
    </outline>
    <outline text="二义性" _note="文法G的某一个句子有两棵不同的树，则G为二义的&#10;&#10;作为描述程序语言的上下文无关文法，有以下限制&#10;&#10;&gt; 1️⃣ G不含以下产生式：P-&amp;gt;P&#10;&gt;&#10;&gt; 2️⃣&#10;&gt; 每一*P* ∈ *V*_(*N*)，必须都有用处，即$\\exists s\\mathop\\Rightarrow\\limits^\* \\alpha P \\beta$，P在句型中出现&#10;&gt;&#10;&gt; $\\exists γ\\in V\_T^\*,P\\mathop\\Rightarrow\\limits^+γ$，即对P不存在不终结的回路&#10;&#10;**题目**&#10;&#10;&gt; 关于文法二义性、语言二义性，下面哪些说法是正确的？&#10;&gt;&#10;&gt; 1️⃣ 只要存在某个句子有两棵不同的语法树,文法就是二义的。&#10;&gt;&#10;&gt; 2️⃣ 无法判定所有句子均没有两棵不同的语法树，即无法判定文法是否无二义。&#10;&gt;&#10;&gt; 3️⃣ 对于语言来说只要存在无二义的文法它就不是二义的。&#10;&gt;&#10;&gt; 4️⃣ 对于语言来说,无法判定其不存在无二义的文法,即无法判定语言是否二义。&#10;&gt;&#10;&gt; ABCD">
    </outline>
  </outline>
  <outline text="参考资料" _note="\[1\] 西安交通大学软件工程专业编译原理 吴晓军 2022春&#10;&#10;\[2\] 陈火旺，刘春林，谭庆平，赵克佳，刘越.&#10;程序设计语言编译原理（第3版）. 北京：国防工业出版社，2010/20132017">
  </outline>
</outline>
  </body>
</opml>
