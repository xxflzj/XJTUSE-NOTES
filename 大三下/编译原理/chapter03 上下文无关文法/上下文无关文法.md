[TOC]



# 第三章 上下文无关文法

![第三章 上下文无关文法](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95.png)

目的：

> 对语言的语法结构进行形式描述
>
> 从形式描述中，研究语法分析器的构造（分析法递归子程序和算符优先分析法）

## 3.1 引言

**文法**：是描述语言的语法结构的形式规则（即语法规则），是为了解决语言的有穷说明问题，包含对语法的描述，但是不表达任何语义

**文法的描述应该达到以下要求**：形式上严格，准确；易于理解；描述能力强；有利于句子的分析和翻译，构造语法分析器

**文法的分类**：分为四类(0,1,2,3型文法)；与程序语言语法有关的是上下文无关文法

上下文无关文法的特点：它所定义的语法范畴（或语法单位）完全独立于这种范畴可能出现的环境。

> 上下文无关文法只能描述一部分语言，但是已经足够描述现今的程序设计语言
>
> 自然语言要用别的描述方法

## 3.2 文法与语言

### 定义

一个上下文无关文法G是一个四元式$(V_T,V_N,S,P)$

> $V_N$：是非空有限集合，它的每个元素是非终结符号
>
> $V_T$：是非空有限集合，它的每个元素是终结符号
>
> $V_N\cap V_N=\empty\qquad V_T\cup V_N=V$
>
> $S$：$S\in V_N$，称为开始符号（相当于有限自动机的初态）
>
> $\mathscr{P}$：产生式集合（有限），每个产生式是
>
> $\{P\rightarrow \alpha|P\in V_N,\alpha \in (V_T\cup V_N)^* ,S至少一次为P\}$,S即要在左边至少出现一次
>
> “$\rightarrow$" 相当于$is\ defined \ as$

**举例**：考虑以下算数表达式的文法以及语言

> $V_T$： id + -  * /  ↑ ( )
> $V_N$：表达式、运算符
> $S$：   表达式
> $\mathscr{P}$： 表达式->表达式 运算符 表达式
> 		 表达式->（表达式）
> 		 表达式->— 表达式
> 		 表达式-> id
> 		 运算符->+|-|*|/|↑
>
> 得到文法G1(E) : E->EAE|(E)|-E|id	A->+|-|*|/|↑
>
> 由此可见，文法G1(E)所定义的语言是算术表达式，如id+id,id*(id+id)等
>
> 它表达了简单算术表达式由id用A连接起来
>
> 该文法的:
>
> :one: $V_N$是出现在P的左部所有符号集合
>
> :two: V是$\mathscr{P}$的所有符号：$V_T=V/V_N$
>
> :three: S是该文法所定义的句子名字
>
> :four: 写出了$\mathscr{P}$，就能找出其它三元素

### 各个符号的意义

:one: **终结符**：是用以组成语言中的串的基本符号，与程序语言中的“单词”是同义语

如表达式 $id+(id)^*(-id)$中，+、-、*、/、id均为终结符

:two: **非终结符**：非终结符号(也称语法变量)用来代表语法范畴。例如,“算术表达式”“布尔表达式”“赋值句”“分程序”“过程”等,它们都是现今程序语言常见的语法范畴。我们也可以说，<mark>一个非终结符代表一个一定的语法概念</mark>。因此，一个非终结符是一个类(或集合)记号,而不是一个个体记号。例如，算术表达式"这个非终结符乃代表一定算术式组成的类。因而,也可以说,<mark>每个非终结符号表示一定符号串的集合</mark>(由终结号和非终结符号组成的符号串）。

:three: **开始符号**：一个特殊的非终结符，标记最终感兴趣的语法范畴（句子），其他非终结符用以定义其他的串集，这有助于定义该语言，也有助于为它处理的语言提供一个分层的结构

:four: **产生式**：规定由终结符和别的语法范畴组成一个新的语法范畴的办法

> 结构：非终结符->一串非终结符和终结符
>
> > 如：A->α，A是左部符号$V_N$，α是右部<mark>候选式</mark>，$\alpha=X_1X_2X_3...X_N,X_i\in V$
>

**举例**

> 语法规则如下：
>
> <句子> → <主语> <谓语> <间接宾语> <直接宾语>
> <主语> → <代词>
> <谓语> → <动词>
> <间接宾语> → <代词>
> <直接宾语> → <冠词> < 名词>
> <代词> → He
> <代词> → me
> <名词> → book
> <冠词> → a
> <动词> → gave
>
> 比如He gave me a book是一个语法正确的句子
>
> :point_right: 该语法范畴叫"**句子**"，在程序语言中叫“ **程序**”
>
> :point_right: 语言的句子是由一串$V_N$定义，到最后才是一串$V_T$

### 习惯记号

$V_N$：大写字母A、B、C、S等

$V_T$：小写字母，0~9，+，-等运算符，标点，分界符，黑体字母串，id，if

X、Y、Z：文法符号，或$V_N$或$V_T$一个符号

u、v、w……z：$V_T$中的串

α、β、γ：文法符号串$\in (V_T\cup V_N)^*$

S：开始符号，第一个产生式中出现

->：定义为(元语言符号)

|：或(元语言符号)

### 推导与语言

:question: 问题：用文法如何定义一个语言？

思路：从S出发，反复使用$\mathscr{P}$，对<mark>非终结符</mark>**替换**展开，最后得到全部由终结符串组成的一个串

涉及到：**替换、推导、句型、句子、语言**



:one: **直接推出**：是两个**文法符号串**之间的一种关系$\mathscr{R}$

如：$(\alpha \ A \ \beta)\  \mathscr{R}\ (\alpha \ γ \ \beta)$

它表示，若$A\rightarrow γ \in \mathscr{P},\ \alpha,\beta \in V^*$，则$\mathscr{R}$就是直接推出，$\mathscr{R}$记作$\Rightarrow$

则有：$(\alpha \ A \ \beta)\  \Rightarrow (\alpha \ γ \ \beta)$

------

:two: **推导**：如果两个串$u_0,u_n$，存在一个串序列
$$
u_0\Rightarrow u_1 \Rightarrow ... \Rightarrow u_n
$$
则$u_0\ \mathscr{R}_1\ u_n\quad \mathscr{R}_1记作\mathop\Rightarrow\limits ^+或\mathop\Rightarrow\limits ^*$

+：至少一步推导。*：可以0步推导

------

:three: **如何从推导引出语言**

​               $u_0\mathop\Rightarrow\limits ^+ u_n$                         $u_0\mathop\Rightarrow\limits ^* u_n$

:cactus:如果令$u_0$为S，即推导要从开始符号开始，那么$S\mathop\Rightarrow\limits ^* \alpha,\alpha\in V^*$，则称α为G的<mark>句型</mark>

:cactus: 如果再要求$\alpha \in V_T^*$，则称$\alpha$为G的<mark>句子</mark>

:cactus: 文法G产生的<mark>句子的全体</mark>是一个语言，记作L(G)
$$
L(G)=\{\alpha |S \mathop\Rightarrow\limits ^+ \alpha \ \&\ \alpha \in V_T ^*\}
$$
**说明**

> ① 由文法G定义语言L需依赖一种运算，即关系$\mathop\Rightarrow\limits ^+$
>
> 当V\*中有许多串，只有那些(S, u) (S,v)存在$\mathop\Rightarrow\limits ^+$关系的u,v才是语言中的**句子**。
>
> ② α , β是**句型**，表示(S， α) (S， β)有$\mathop\Rightarrow\limits ^*$的关系，但它们的构成是不全属于$V^T$的字符。
>
> ③ G的**句型集**，是指存在$S\mathop\Rightarrow\limits ^* \alpha$关系的所有α,该集的子集是L(G)。
>
> ④$L(G)\subset 句型集 \subset V^*$

**题目**

> 关于句型、句型集、句子、语言等概念，下面哪些说法是不正确的?
>
> A 终结符串是句子（句子是终结符串）
>
> B 终结符与非终结符的混合串是句型
>
> C 终结符集合的闭包是语言
>
> D 全体符合集合的闭包是甸句集
>
> ABCD

**举例**：根据文法G： E->E+E|E\*E|(E)|i，句子$i_1*(i_2+i_3)$的推导过程如下

> :one: $E=>E*E=>i_1*E=>i_1(E)=>i_1*(E+E)=>i_1*(i_2+E)=>i_1*(i_2+i_3)$
>
> 最左推导
>
> :two: $E=>E*E=>E*(E)=>E*(E+E)=>E*(E+i_3)=>E*(i_2+i_3)=>i_1*(i_2+i_3)$
>
> 最右推导

从一个句型到另一个句型的推导过程并不唯一，但是通常只考虑<mark>最左推导和最右推导</mark>

> 最左推导是指，任何一步a=> β都是对a中的<mark>最左非终结符</mark>进行替换。
>
> 最右推导是指，任何一步a=> β都是对a中的<mark>最右非终结符</mark>进行替换。

## 3.3 语法树与二义性

### 语法树

**目的**：为了理解句子的语法，即理解句子如何从开始符号推导得到，因此引入“图”。

**定义**：句型推导的图形表示，与**替换顺序的选取**无关。

**作用**：明显地形成文法所暗含句子的分层语法结构，为语法分析提供一些新的途径。

**树的内结点**：非终结符A标记，若A->XYZ，则该产生式的一棵子树为

![image-20220315174336689](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220315174336689.png)

**语法树与文法概念的对应关系如下**

| 语法树                    | 文法概念 |
| ------------------------- | -------- |
| 内结点A                   | VN       |
| 叶                        | 文法符号 |
| 子树                      | 直接推导 |
| 根结点                    | S        |
| 任意一次全剪              | 句型     |
| 叶子∈VT时，将叶子顺序排列 | 句子     |

有的文法，对于同一句子，应用不同规则进行推导得到不同的语法树

> 没有区分优先级

**举例** $E\mathop\Rightarrow\limits^+ -(id+id)$的语法树

> 最左推导：E=>-E=>-(E)=>- (E+E) =>-(id+E) =>- (id+id)
> 最右推导：E=>-E=>-(E) =>- (E+E) =>-(E+id)=>- (id+id)
>
> ![image-20220315205033733](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220315205033733.png)
>
> 每一个中间过程，句型很容易获取
>
> 树忽略了符号的替换顺序的不同，不同的推导过程得到相同的语法树
>
> 有的文法，对于同一句子，应用不同规则进行推导会得到不同的语法树

**举例：根据文法G对句子id+id*id进行推导**

> 文法G：E->E+E|E*E|(E)|i
>
> 推导1
>
> E=>E+E=>id+E=>id+E\*E=>id+id\*E=>id+id*id
>
> 推导2
>
> E=>E\*E=>E+E\*E=>id+E*E=>id+id\*E=>id+id\*id
>
> ![image-20220315205919198](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220315205919198.png)

### 二义性

文法G的某一个句子有两棵不同的树，则G为<mark>二义的</mark>

作为描述程序语言的上下文无关文法，有以下限制

> :one: G不含以下产生式：P->P
>
> :two: 每一$P∈V_N$，必须都有用处，即$\exists s\mathop\Rightarrow\limits^* \alpha P \beta$，P在句型中出现
>
> $\exists γ\in V_T^*,P\mathop\Rightarrow\limits^+γ$，即对P不存在不终结的回路



**题目**

> 关于文法二义性、语言二义性，下面哪些说法是正确的？
>
> :one: 只要存在某个句子有两棵不同的语法树,文法就是二义的。
>
> :two: 无法判定所有句子均没有两棵不同的语法树，即无法判定文法是否无二义。
>
> :three: 对于语言来说只要存在无二义的文法它就不是二义的。
>
> :four: 对于语言来说,无法判定其不存在无二义的文法,即无法判定语言是否二义。
>
> ABCD

## 参考资料

[1] 西安交通大学软件工程专业编译原理 吴晓军 2022春

[2] 陈火旺，刘春林，谭庆平，赵克佳，刘越. 程序设计语言编译原理（第3版）. 北京：国防工业出版社，2010

