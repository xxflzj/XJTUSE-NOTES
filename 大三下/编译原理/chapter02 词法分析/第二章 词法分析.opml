<?xml version="1.0" encoding="UTF-8"?>
<opml version="2.0">
  <head>
    <title></title>
    <dateModified></dateModified>
    <ownerName></ownerName>
  </head>
  <body>
<outline text="第二章 词法分析" _note="词法分析的任务:从左至右逐个字符地扫描源程序，产生一个个的**单词符号，**把作为字符串的源程序改造成为单词符号串的中间程序。&#10;&#10;词法分析器/扫描器：**执行词法分析的程序。**&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305162321676.png)">
  <outline text="2.1 对词法分析器的要求">
    <outline text="1、词法分析器的功能和输出形式" _note="词法分析器的功能:输入源程序，输出单词符号。  &#10;单词符号:一个程序语言的基本语法符号，分为以下5种:&#10;&#10;&gt; 1、关键字:由程序语言定义的具有固定意义的标识符。也可称为保留字或基本字。例如:&#10;&gt; Pascal中的begin,end，if等。它是**确定的**。&#10;&gt;&#10;&gt; 2、标识符:用来表示各种名字，如变量名、数组名、过程名等。它是**不限的**。&#10;&gt;&#10;&gt; 3、常数:常数的类型一般有整型、实型、布尔型、文字型等。它是**不限的**。&#10;&gt;&#10;&gt; 4、运算符:如+、一、\*、/等。它是**确定的**。&#10;&gt;&#10;&gt; 5、界符:如逗号、分号、括号、/*，*/等。它是**确定的**。&#10;&#10;**单词符号的表示形式**:词法分析器所输出的单词符号常常表示成二元式&#10;&#10;    (单词种别，单词自身的值)&#10;&#10;**单词种别**可以用以下形式表示:&#10;&#10;&gt; 1、一类单词统一用**一个整数**值代表其属性。例如:1代表关键字，2代表标识符等。&#10;&gt;&#10;&gt; 2、每一个单词一个类别。例如:1代表BEGIN，2代表END等。&#10;&#10;**单词自身的值**可以表示成:**常量的二进制表示**;常量、变量等在符号表中的地址码，等等。&#10;&#10;&gt; 🏷&#10;&gt; **注意**:一个语言的单词符号如何分种，分几种，怎样编码，是一个技术问题。标识符一般同归为一种。常数则宜按类型（整、实、布尔）分。关键字可以将其全体视为一种，也可**一字一种**。运算符可采用一符一种，但也可把具有一定共性的视为一种。界符则一般采用**一符一种**。如何进行分种主要取决于处理上的方便。&#10;&gt;&#10;&gt; 若是一符一种分种，单词自身值就不需要了。否则，要查符号表。&#10;&#10;**举例**：151-FORTRAN编译程序的词法分析在扫描输入串`IF (5·EQ·M) GOTO 100`后，它输出的单词符号串是：&#10;&#10;[TABLE]">
    </outline>
    <outline text="2、词法分析与语法分析的关系" _note="**把词法分析从语法分析中脱离出来的优点**&#10;&#10;&gt; 1️⃣ 使编译程序的**结构**更加简洁、清晰和条理化（解耦）&#10;&gt;&#10;&gt; 2️⃣&#10;&gt; 词法分析和语法分析**方法**不同，词法分析可以使用正则文法自动构scanner简单。&#10;&gt;&#10;&gt; 3️⃣ 有利于提高语法分析的**效率**。&#10;&gt;&#10;&gt; 4️⃣&#10;&gt; 可以改善词法分析的细节，甚至于一个语法分析配几个scanner，把不同输入变成一种内部表示。&#10;&#10;**把词法分析作为独立的一遍**&#10;&#10;&gt; scanner当作一遍：串行化处理的风格&#10;&gt;&#10;&gt; 把scanner当作子程序：主程序子程序的风格&#10;&gt;&#10;&gt; ![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305164157680.png)&#10;&#10;基于关注点分离来解耦">
    </outline>
  </outline>
  <outline text="2.2 词法分析器的设计" _note="设计前提：把scanner作为独立的一个子程序；词法分析器的任务为输出单词符号&#10;&#10;主程序子程序风格">
    <outline text="1、预处理" _note="必要性：编辑性字符如空白符、回车符等，除了出现在文字常数中以外，在别处出现都没有意义。&#10;&#10;功能：剔除无用字符&#10;&#10;实现：预处理子程序&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305202620814.png)&#10;&#10;若识别输入语句`IF (5·EQ·M) GOTO 100`，缓冲区的情况如下&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305203302351.png)&#10;&#10;扫描缓冲区**只装了语句的一部分**&#10;&#10;&gt; 如果只用一个缓冲区，读入下一部分地时候会丢失指示器内容，所以需要两个缓冲区&#10;&#10;扫描缓冲区的结构：&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305203806655.png)&#10;&#10;&gt; 缓冲区大小：120字符&#10;&gt;&#10;&gt; 采用两个指示器：起点指示器、搜索指示器&#10;&gt;&#10;&gt; 两个互补区">
    </outline>
    <outline text="2、单词符号的识别——超前搜索" _note="单词符号识别的简单方法：超前搜索&#10;&#10;&gt; 识别关键字时需要多读后面的一些字符，以区分不同的语法&#10;&#10;用到超前搜索的场景：&#10;&#10;&gt; 1️⃣ 标识符的识别&#10;&gt;&#10;&gt; 2️⃣ 常数的识别&#10;&gt;&#10;&gt; 3️⃣ 算符和界符的识别&#10;&gt;&#10;&gt; &gt; 如c++中的++和--">
    </outline>
    <outline text="3、状态转换图" _note="**转换图**：是一张**有限方向图**（允许有环），结点表示状态、用圆圈表示；状态之间用箭弧连接。箭弧上的标记（字符）代表在射出结点状态下可能出现的输入字符或字符类&#10;&#10;**功能**：识别一定的字符串&#10;&#10;**初态**：一张状态图的启动条件，至少有一个，用圆圈表示&#10;&#10;**终态**：一张状态图的结束条件，至少有一个，用双圈表示&#10;&#10;**\***：表示多读进了一个字符（超前搜索）&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220228084125703.png)&#10;&#10;**a）图表示**：在状态1下，若输入字符为X，则读进X，并转换到状态2；若输入字符为Y，则读进Y，并转换到状态3；这并不是一个完整的状态图（没有终态）&#10;&#10;**b）图表示**：状态0开始,若在状态0之下输人字符是一个字母,则读进它,并转人状态1。在状态1之  &#10;下,若下一个输入字符为字母或数字,则读进它,并重新进入状态1。一直重复这个过程，直到状态1发现输人字符不再是字母或数字时(这个字符也已被读进)就进入状态2。状态2是终态,它意味着到此已识别出一个标识符,识别过程宣告终止。终态结上打个星号意味着多读进了一个不属于标识符部分的字符,应把它退还给输人串。如果在状态&#10;0时输入字符不为“字母”,则意味着识别不出标识符,或者说,这个转换图工作不成功。">
    </outline>
    <outline text="4、状态转换图的实现" _note="程序化所需要的变量和过程：&#10;&#10;1️⃣ **ch** 字符变量,存放最新读进的源程序字符。&#10;&#10;2️⃣ **strToken** 字符数组,存放构成单词符号的字符串。&#10;&#10;3️⃣ **GetChar**&#10;子程序过程,将下一输入字符读到ch中,搜索指示器前移一字符位置。&#10;&#10;4️⃣ **GetBC** 子程序过程，检查 ch 中的字符是否为空白。若是，则调用&#10;CetChar直至 ch 中进人一个非空白字符。&#10;&#10;5️⃣ **Concat**&#10;过程,将ch中的字符连接到strToken之后。例如,假定strToken原来的值为“AB”,而ch中存放着'C',经调用Concat后,strToken的值就变为“ABC”。&#10;&#10;6️⃣ **IsLetter和 IsDigit**&#10;布尔函数过程，它们分别判断ch中的字符是否为字母和数字。&#10;&#10;7️⃣ **Reserve** 整型函数过程,对 strToken&#10;中的字符串查找保留字表,若它是一个保留字则返回它的编码,否则返回0值(假定0不是保留字的编码)。&#10;&#10;8️⃣ **Retract** 子程序过程,将搜索指示器回调一个字符位置,将 ch&#10;置为空白字符。&#10;&#10;9️⃣ **InsertId**&#10;整型函数过程,将stToken中的标识符插人符号表,返回符号表指针。&#10;&#10;0️⃣ **InsenConst**&#10;整型函数过程,将stroken中的常数插人常数表,返回常数表指针。&#10;&#10;这些函数和子程序过程都不难编制。使用它们能够方便地构造状态转换图的对应程  &#10;序。一般来说,可让**每个状态结点对应一程序段**&#10;&#10;对于不含回路的分叉结点来说,可让它对应一个swich语句或一组if…then…else语句。终态结点一般对应turn(code,value)语句，其中code为单词种别编码，vlue是字符数组的strToken（或者是一个整数值，或者无定义）。具体见后面实例。&#10;&#10;为了**把状态图转换为程序**，每个状态需要建立一段程序，他要做的工作如下：&#10;&#10;1️⃣&#10;从输入缓冲区中取一个字符，为此需要使用函数**GetChar**，每次调用它，推进先行指针，送回1个字符。&#10;&#10;2️⃣&#10;确定在本状态下，哪一条箭弧是用刚刚来的输入字符标识的。如果找到，控制就转到该弧所指向的状态；若找不到，那么寻找该单词的企图就失败了。&#10;&#10;❌&#10;失败：先行指针必须重新回到开始指针处，并用另一状态图来搜索**另一单词**。如果所有的状态转换图试过之后，还没有匹配的，就表明这是个**词法错误**，此时调用错误校正程序&#10;&#10;**举例**&#10;&#10;以下为case语句及其对应的状态图&#10;&#10;    state i: GetChar;&#10;    		 Case ch OF&#10;    		 'A'--'Z':…… state j ……;&#10;    		 '0'--'9':…… state k ……;&#10;    		 '/'     :…… state l ……;&#10;    		 END;&#10;    		 Fail()&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305205636425.png)&#10;&#10;**示例**&#10;&#10;将状态结点对应于一段程序&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305205758429.png)&#10;&#10;    state0: C:=GetChar;&#10;    		if IsLetter(C) then goto state 1&#10;    		else Fail();&#10;    		/*Fail()是子程序，它移动先行指针，开始下一个状态转换图，或者调用出错程序*/&#10;    state1: C:=GetChar;&#10;    		if IsLetter(C) or IsDigit(C)&#10;                then goto state 1&#10;            else if Delimiter(C)/*是过程，只要碰到标识符后的分界符，它返回TRUE*/&#10;                	/*分界符一般为空格、算数、逻辑符号、括号、&quot;=&quot;、&quot;;&quot;、&quot;,&quot;、&quot;.&quot;、&quot;,&quot;*/&#10;                them goto state 1&#10;            else Fail();&#10;    state2: Retract();/*将超前搜索的字符回调一个*/&#10;    		return(&amp;id, Install());/*判断是否为保留字，所有的保留字，一字一码*/&#10;&#10;如果要同时识别标识符和定义符，则需要修改state2&#10;&#10;    state2: Retract();&#10;    		C := Reserve();/*对strToken 中的字符串查找保留字表,若它是一个保留字则返回它的编码,否则							返回0值(假定0不是保留字的编码)。*/&#10;            if C = 0&#10;              then return(&amp;id, Install())&#10;            else return(C,_) &#10;&#10;词法分析方法的步骤如下&#10;&#10;1️⃣ 给出程序设计语言的单词规范（单词表）&#10;&#10;2️⃣ 对照单词表设计识别该语言所有单词的状态转换图&#10;&#10;3️⃣ 根据状态转换图编写词法分析程序&#10;&#10;&gt; 手动方法效率低&#10;&#10;所以需要自动化方式">
    </outline>
  </outline>
  <outline text="2.3 正规表达式和有限自动机">
    <outline text="1、预备知识" _note="字母表是一个非空有限集合，用∑表示&#10;&#10;字母表中的元素称为该字母表中的字母，或者符号，或者字符&#10;&#10;字母表两个特性：非空性、有穷性&#10;&#10;字符两个特性：整体性（不可分性）、可辨认性（可区分性）&#10;&#10;字母表的乘积:∑₁*与*∑₂的乘积记作&#10;&#10;∑₁∑₂ = {*a**b*|*a* ∈ ∑₁, *b* ∈ ∑₂}&#10;&#10;**字母表的幂**：&#10;&#10;&gt; 1️⃣&#10;&gt; $\\sum^0=\\{\\varepsilon\\},\\ 其中\\varepsilon是由\\sum中的0个字符组成的$&#10;&gt;&#10;&gt; 2️⃣ ∑^(*n*) = ∑^(*n* − 1)∑,*n* ≥ 1&#10;&#10;**字母表的闭包**：&#10;&#10;1️⃣&#10;∑*的**正**闭**包*(*p**o**s**i**t**i**v**e* *c**l**o**s**u**r**e*)：∑⁺ = ∑ ∪ ∑² ∪ ∑³ ∪ ……&#10;&#10;1️⃣&#10;∑*的**克**林**闭**包*(*K**l**e**e**n**e* *c**l**o**s**u**r**e*)：∑^(\*) = ∑⁰ ∪ ∑⁺ = {*ε*} ∪ ∑⁺&#10;&#10;**句子**&#10;&#10;&gt; 句子：字符串对于任何*x* ∈ ∑^(\*)，x即∑上的一个句子（sentence）&#10;&gt;&#10;&gt; 句子又可被称为字（word），字符行/符号行或者字符串/符号串&#10;&#10;程序设计语言的单词规范——**单词表**可以与**正规集**建立起一一对应关系，进而与**正规式**建立起一一对应关系">
    </outline>
    <outline text="2、正规式与正规集" _note="∑^(\*)*的**子**集**U*, *V*&#10;&#10;&gt; 积： *U**V* = {*α**β*|*α* ∈ *U* &amp; *β* ∈ *V*}&#10;&gt;&#10;&gt; n次积： *V*^(*n*) = *V**V**V*...*V*   *V*⁰ = {*ε*}&#10;&gt;&#10;&gt; V的闭包： *V*^(\*) = *V*⁰ ∪ *V*¹ ∪ *V*² ∪ ……&#10;&gt;&#10;&gt; V的正则闭包 *V*⁺ = *V* *V*^(\*)&#10;&#10;对于字母表∑,我们感兴趣的是它的一些特殊字集,即所谓正规集。我们将使用正规式这个概念来表示正规集。下面是正规式和正规集的递归定义：&#10;&#10;1️⃣ *ε*和$\\empty$都是∑上的正规式,它们所表示的正规集分别为{*ε*}和&#10;$\\empty$;&#10;&#10;2️⃣ 任何 *a* ∈ ∑ 是 ∑ 上的一个正规式，它所表示的正规集为{*a*}；&#10;&#10;3️⃣&#10;&#10;[TABLE]&#10;&#10;仅由有限次使用上述三步骤而得到的表达式才是&#10;Σ上的正规式。仅由这些正规式所表示的字集才是 ∑上的正规集。&#10;&#10;**举例**&#10;&#10;&gt; 1️⃣ 令 ∑ = {*a*, *b*},下面是∑上的正规式和相应的正规集：&#10;&gt;&#10;&gt; [TABLE]&#10;&gt;&#10;&gt; 2️⃣ 令∑ = {*A*, *B*, 0, 1},则&#10;&gt;&#10;&gt; [TABLE]&#10;&#10;如果两个正规式生成的正规集是一样的，那么这两个正规式是等价的,，记作U=V&#10;&#10;**正规式上的运算律**&#10;&#10;&gt; 令U、V和W均为正规式,显而易见,下列关系普遍成立：  &#10;&gt; 1️⃣ *U*|*V* = *V*|*U*(*交**换**律*)&#10;&gt;&#10;&gt; 2️⃣ *U*|(*V*|*W*) = (*U*|*V*)|*W*(*结**合**律*)&#10;&gt;&#10;&gt; 3️⃣ *U*(*V**W*) = (*U**V*)*W*(*结**合**律*)&#10;&gt;&#10;&gt; 4️⃣ *U*(*V*|*W*) = *U**V*|*U**W*(*分**配**律*)&#10;&gt;&#10;&gt; 5️⃣ (*V*|*W*)*U* = *V**U*|*W**U*&#10;&gt;&#10;&gt; 6️⃣&#10;&gt; $\\varepsilon U= U\\varepsilon = U (吸收率)\\qquad	\\varepsilon表示空字符串$&#10;&#10;&gt; *ε*是一个字，但不是字符，是一个正规式&#10;&gt;&#10;&gt; ∅是一个集合，也是一个正规式">
    </outline>
    <outline text="3、确定有限自动机（DFA）" _note="一个`确定有限自动机(DFA)`M是一个五元式&#10;&#10;*M* = (*S*, ∑,*δ*, *s*₀, *F*)&#10;&#10;其中  &#10;1️⃣ *S*是一个 有限集，它的每个元素称为一个状态.。&#10;&#10;2️⃣ ∑是一个有穷字母表，它的每个元素称为一个输入字符。&#10;&#10;3️⃣&#10;*δ*是一个从*S* × ∑至*S*的单值部分映射。*δ*(*s*, *a*) = *s*′意味着：当现行状态为s、输人字符为a时,将转换到下一状态*s*′，我们称*s*′为s的一个后继状态。&#10;&#10;4️⃣ *s*₀ ∈ *S*是唯一的初态&#10;&#10;5️⃣ *F* ⊆ *S*，是一个终态集（可空）——可能是某个DFA的一部分&#10;&#10;显然，一个DFA可用一个矩阵表示,该矩阵的行表示状态,列表示输人字符,矩阵元素表示*δ*(*s*, *a*)的值。这个矩阵称为状态转换矩阵。例如,有DFA&#10;&#10;**举例**&#10;&#10;&gt; 有DFA , *M* = ({0, 1, 2, 3}, {*a*, *b*}, *δ*, 0, {3})&#10;&gt;&#10;&gt; 其中*δ*为&#10;&gt;&#10;&gt; *δ*(0, *a*) = 1   *δ*(0, *b*) = 2&#10;&gt;&#10;&gt; *δ*(1, *a*) = 3   *δ*(1, *b*) = 2&#10;&gt;&#10;&gt; *δ*(2, *a*) = 1   *δ*(2, *b*) = 3&#10;&gt;&#10;&gt; *δ*(3, *a*) = 3   *δ*(3, *b*) = 3&#10;&gt;&#10;&gt; 对应的状态转换矩阵如下:&#10;&gt;&#10;&gt; [TABLE]&#10;&#10;一个DFA也可表示成一张(确定的)**状态转换图**。假定DFA M 含有 m 个状态和 n&#10;个**输入字符**,那么,这个图含有 m&#10;个**状态结点**,每个结点**顶多有n条**箭弧射出和别的结点相连接,每条箭弧用∑中的一个不同输人字符作标记,整张图含有唯一的一个**初态结点**和若干个(可以是0个)终态结点。&#10;&#10;上例转换为状态转换图为：&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305215236682.png)&#10;&#10;对于∑^(\*)中的任何字α,若存在一条从初态结点到某一终态结点的通路,且这条通路上所有弧的标记符连接成的字等于α,则称α可为&#10;DFA M所识别(读出或接受)。若 M 的初态结点同时又是终态结点，则空字。可为 M&#10;所识别(或接受)。DFA M 所能识别的字的全体记为L(M)。&#10;&#10;**举例：数字常量的正则表达式对应的DFA**&#10;&#10;&gt;     digit = [0-9] /*数字0-9*/&#10;&gt;     nat = digit+ /*无符号整数*/&#10;&gt;     signedNat = (+ | -)?nat /*有符号整数*/&#10;&gt;     number = signedNat(&quot;.&quot;nat)? /*一般的数字*/&#10;&gt;&#10;&gt; ![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305220759370.png)&#10;&#10;&gt; 正则表达式(regular&#10;&gt; expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。&#10;&gt;&#10;&gt; 例如：&#10;&gt;&#10;&gt; -   **yjq+b**，可以匹配 **yjqb、yjqqb、yjqqqqb** 等，**+**&#10;&gt;     号代表前面的字符必须至少出现一次（1次或多次）。&#10;&gt;&#10;&gt; -   **yjq\*b**，可以匹配**yjb、yjqb、yjqqb、yjqqqqb** 等，**\***&#10;&gt;     号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。&#10;&gt;&#10;&gt; -   **yj?q** 可以匹配 **yq** 或者 **yjq**，**?**&#10;&gt;     问号代表前面的字符最多只可以出现一次（0次或1次）。&#10;&#10;**举例：区分只有一个和包含最多一个**&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220305222228325.png)&#10;&#10;如果一个DFA M的输入字母表为Σ,则我们也称M是Σ上的一个DFA。可以证明：  &#10;**∑上的一个字集V真包含于∑^(\*)是正规的,当且仅当存在Σ上的DFAM,使得V=L(M)。**&#10;&#10;&gt; 不能是包含于，否则是无限的&#10;&#10;DFA的确定性表现在映射*δ*：*S* × *Σ* → *S*是一个**单值函数**。也就是说,对任何状态*s* ∈ *S*和输入符号*a* ∈ *Σ*，*δ*(*s*, *a*)唯一地确定了下一状态。从转换图的角度来看,假定字母表Σ含有&#10;n 个输人字符,那么,任何一个状态结最多只有 n&#10;条弧射出,而且每条弧以一个不同的输入字符标记。如果也允许∑是一个多值函数,我们就得到非确定自动机的概念。">
    </outline>
    <outline text="4、非确定有限自动机（NFA）">
      <outline text="NFA的定义" _note="一个`非确定有限自动机(NFA)`M是一个五元式&#10;&#10;*M* = (*S*, ∑,*δ*, *S*₀, *F*)&#10;&#10;其中  &#10;1️⃣ *S*是一个 有限集，它的每个元素称为一个状态.。&#10;&#10;2️⃣ ∑是一个有穷字母表，它的每个元素称为一个输入字符。&#10;&#10;3️⃣&#10;*δ*是一个从*S* × ∑^(\*)至*S*的子集的映射。*δ*：*S* × ∑^(\*) → 2^(*S*)&#10;&#10;4️⃣ *S*₀ ⊆ *S*是一个非空初态集&#10;&#10;5️⃣ *F* ⊆ *S*，是一个终态集（可空）——可能是某个DFA的一部分&#10;&#10;显然，一个含有&#10;m个状态和n个输入字符的NFA可表示成如下的状态转换图：该图含有&#10;m个状态结点,每个结点**可射出若干条箭弧**与别的结点相连接,每条弧用&#10;∑^(\*)中的一个字(**不一定要不同的字而且可以是空字&#10;**)作标记(称为输人字),整张图至少含有一个初态结点以及若干个(可以是&#10;0个)终态结点。某些结点既可以是初态结点也可以是终态结点。&#10;&#10;对于∑^(\*)中的任何一个字α,若存在一条从某一初态结点到某一终态结点的通路,且这条通路上所有弧的标记字依序连接成的字(忽略那些标记为ε的弧)等于α,则称α可为NFA&#10;M&#10;**所识别**(读出或接受)。若M的某些结点既是初态结点又是终态结点,或者存在条从某个初态结点到某个终态结点的ε通路,那么,空字ε可为M所接受。&#10;&#10;&gt; 箭弧上是一个串或者空字的是NFA&#10;&#10;**举例：下图所示的状态转换图的*S*、∑、∑^(\*)**如下&#10;&#10;&gt; *S* = {*x*, 1, 2, 3, 4, 5, 6, *y*}：x，y表示NFA的初态结点和终态结点只有一个&#10;&gt;&#10;&gt; ∑ = {*a*, *b*}&#10;&gt;&#10;&gt; $\\sum ^\*=\\{\\alpha|\\alpha为ε，或者为a、b的任意组合\\}$&#10;&gt;&#10;&gt; ![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220311211128802.png)&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220311204803165.png)&#10;&#10;从状态图看NFA和DFA的区别&#10;&#10;&gt; NFA可以有多个初态；弧上的标记可以是一个字（甚至是正规式），而不一定是单个字符；同一个字可能出现在同状态射出的多条弧上&#10;&gt;&#10;&gt; DFA是NFA的特例&#10;&gt;&#10;&gt; [TABLE]">
      </outline>
      <outline text="ε_CLOSURE(I)的定义" _note="假定I是NFA M的状态集的一个子集，定义ε\_CLOSURE(I)如下：&#10;&#10;1️⃣&#10;*若**s* ∈ *I*, *则**s* ∈ *ε*\_*C**L**O**S**U**R**E*(*I*)：状态子集中的每一个元素都是闭包中的元素&#10;&#10;2️⃣&#10;若*s* ∈ *I*,那么从s出发经任意条ε弧而能到达的任意状态s'都属于ε\_CLOSURE(I)&#10;&#10;状态集ε\_CLOSURE(I)称为I的ε闭包">
      </outline>
      <outline text="Ia的定义" _note="假定I是NFA M的状态集的一个子集。*a* ∈ ∑，定义&#10;&#10;*I*_(*a*) = *ε*\_*C**L**O**S**U**R**E*(*J*)&#10;&#10;其中，J是那些可以从I中的某一个状态节点出发经过一条a弧而到达的状态节点的全体">
      </outline>
      <outline text="子集算法【重点】" _note="使用子集法将非确定有限自动机（NFA）转换为确定有限自动机(DFA)时首先要引入状态节点&#10;X，其目的是否为解决初态节点惟一性&#10;&#10;1️⃣ 表的初始化&#10;&#10;&gt; ∑ = {*a*₁, *a*₂, ..., *a*_(*k*)},先构造一张表，该表每行含有k+1列。置该表的首行首列为*ε*\_*C**L**O**S**U**R**E*(*x*)&#10;&#10;2️⃣ 处理表的一行&#10;&#10;&gt; 如果某一行的第一列的状态子集已经确定，例如记作I，那么，求出这一行的第二个和第三个子集Ia和Ib看它们是否已经在表的第一列出现，将未出现的**填入**到后面空行的第一列&#10;&#10;3️⃣ 重复处理&#10;&#10;&gt; 重复上述过程，直到所有第二列和第三列的所有状态子集均已经在第一列中出现&#10;&#10;**举例：将下图的NFA按照上述证明过程进行DFA化**&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220311211303125.png)&#10;&#10;[TABLE]&#10;&#10;&gt; 以第一行Ia为例：初始子集为I={x,5,1},从I中的某一个状态节点出发经过一条a弧而到达的状态节点的全体为{5，3}，在这个子集的基础上的空字闭包为{5,3,1}，所以Ia为{5，3，1}&#10;&#10;对上图的表格中的所有子集进行重命名，可以得到新的状态转换矩阵，从而得到相应的DFA，如图所示&#10;&#10;[TABLE]&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220311212712247.png)">
      </outline>
    </outline>
  </outline>
  <outline text="2.4 正规文法与有限自动机的等价性" _note="对于正规文法 G 和有限自动机 M,如果 L(C)= L(M),则称 G 和M&#10;是等价的。关于正规文法和有限自动机的等价性,有以下结论：&#10;&#10;1️⃣ 对每一个右线性正规文法 G或左线性正规文法&#10;G，都存在一个有限自动机（FA）  &#10;M,使得L(M)=L(G)。&#10;&#10;2️⃣ 对每一个 FA M,都存在一个右线性正规文法 GR和左线性正规文法&#10;G.使得L(M)=L(GR)=L(GL)。">
  </outline>
  <outline text="2.5 正规式与有限自动机的等价式" _note="1️⃣ 对任何FA M,都存在一个正规式r,使得L(r)=L(M)。&#10;&#10;2️⃣ 对任何正规式 r,都存在一个 FA M,使得 L(M)= L(r)。">
  </outline>
  <outline text="2.6 确定有限自动机的化简" _note="一个DFA M的化简是指：寻找一个状态数比M少的DFA M'，使得L(M)=L(M')。&#10;&#10;一个DFA&#10;M的状态最少话过程旨在将M的状态集分割成一些不相交的子集，使得任何不同的两个字集中的状态都是可区别的，而同一子集中的任何两个状态都是等价的&#10;&#10;考虑如下DFA的化简&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220311212712247.png)&#10;&#10;1️⃣ 先按照状态和非终态分组：终态组{3，4，5，6}和非终态组{0，1，2}&#10;&#10;2️⃣ 检查一步转移（后继状态）&#10;&#10;[TABLE]&#10;&#10;3️⃣&#10;{3，6}和{4，5，6}**包含于**{3，4，5，6}，所以{3，4，5，6}不需要划分；但是{1，3}和{2，5}不包含于{0，1，2}，观察后继状态，状态1经过a弧到达状态3，而状态0，2经a弧到达状态1，所以分成{1}，{0，2}&#10;&#10;4️⃣&#10;{1}只有一个元素，不需要继续检查，只用继续检查{0，2}，0经过b到2，2经过b到5，继续分割为{0}，{2}&#10;&#10;5️⃣ 所以最终的划分为{3，4，5，6}，{0}，{1}，{2}&#10;&#10;将状态3代表{3，4，5，6}，化简的状态转换图如下：&#10;&#10;![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220311214018758.png)">
  </outline>
  <outline text="参考资料" _note="\[1\] 西安交通大学软件工程专业编译原理 吴晓军 2022春&#10;&#10;\[2\] 陈火旺，刘春林，谭庆平，赵克佳，刘越.&#10;程序设计语言编译原理（第3版）. 北京：国防工业出版社，2010/20132017">
  </outline>
</outline>
  </body>
</opml>
