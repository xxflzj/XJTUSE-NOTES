[TOC]

# 第二章 词法分析

![第二章 词法分析](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90.png)

词法分析的任务:从左至右逐个字符地扫描源程序，产生一个个的**单词符号，**把作为字符串的源程序改造成为单词符号串的中间程序。

词法分析器/扫描器：**执行词法分析的程序。**

![image-20220305162321676](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305162321676.png)

## 2.1 对词法分析器的要求

### 1、词法分析器的功能和输出形式

词法分析器的功能:输入源程序，输出单词符号。

单词符号:一个程序语言的基本语法符号，分为以下5种:

> 1、关键字:由程序语言定义的具有固定意义的标识符。也可称为保留字或基本字。例如: Pascal中的begin,end，if等。它是**确定的**。
>
> 2、标识符:用来表示各种名字，如变量名、数组名、过程名等。它是**不限的**。
>
> 3、常数:常数的类型一般有整型、实型、布尔型、文字型等。它是**不限的**。
>
> 4、运算符:如+、一、\*、/等。它是**确定的**。
>
> 5、界符:如逗号、分号、括号、/\*，*/等。它是**确定的**。

**单词符号的表示形式**:词法分析器所输出的单词符号常常表示成二元式

```
(单词种别，单词自身的值)
```

**单词种别**可以用以下形式表示:

> 1、一类单词统一用**一个整数**值代表其属性。例如:1代表关键字，2代表标识符等。
>
> 2、每一个单词一个类别。例如:1代表BEGIN，2代表END等。

**单词自身的值**可以表示成:**常量的二进制表示**;常量、变量等在符号表中的地址码，等等。

> :label: <mark> **注意**</mark>:一个语言的单词符号如何分种，分几种，怎样编码，是一个技术问题。标识符一般同归为一种。常数则宜按类型（整、实、布尔）分。关键字可以将其全体视为一种，也可**一字一种**。运算符可采用一符一种，但也可把具有一定共性的视为一种。界符则一般采用**一符一种**。如何进行分种主要取决于处理上的方便。
>
> 若是一符一种分种，单词自身值就不需要了。否则，要查符号表。

**举例**：151-FORTRAN编译程序的词法分析在扫描输入串`IF (5·EQ·M) GOTO 100`后，它输出的单词符号串是：

| 单词符号 | 词法表示                |
| -------- | ----------------------- |
| 逻辑IF   | (34, _)                 |
| 左括号   | (2, _)                  |
| 整常数   | (20, '5'的二进制表示)   |
| 等号     | (6, _)                  |
| 标识符   | (26, 'M')               |
| 右括号   | (16, _)                 |
| GOTO     | (30, _)                 |
| 标号     | (19, '100'的二进制表示) |

### 2、词法分析与语法分析的关系

**把词法分析从语法分析中脱离出来的优点**

> :one: 使编译程序的**结构**更加简洁、清晰和条理化（解耦）
>
> :two: 词法分析和语法分析**方法**不同，词法分析可以使用正则文法自动构造scanner简单。
>
> :three: 有利于提高语法分析的**效率**。
>
> :four: 可以改善词法分析的细节，甚至于一个语法分析配几个scanner，把不同输入变成一种内部表示。

**把词法分析作为独立的一遍**

> scanner当作一遍：串行化处理的风格
>
> 把scanner当作子程序：主程序子程序的风格
>
> ![image-20220519151252314](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220519151252314.png)

基于关注点分离来解耦

## 2.2 词法分析器的设计

设计前提：<mark>把scanner作为独立的一个子程序</mark>；词法分析器的任务为输出单词符号

主程序子程序风格

### 1、预处理

必要性：编辑性字符如空白符、回车符等，除了出现在文字常数中以外，在别处出现都没有意义。

功能：剔除无用字符

实现：预处理子程序

![image-20220305202620814](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305202620814.png)

若识别输入语句`IF (5·EQ·M) GOTO 100`，缓冲区的情况如下

![image-20220305203302351](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305203302351.png)

扫描缓冲区**只装了语句的一部分**

> 如果只用一个缓冲区，读入下一部分地时候会丢失指示器内容，所以需要两个缓冲区

扫描缓冲区的结构：

![image-20220305203806655](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305203806655.png)

> 缓冲区大小：120字符
>
> 采用两个指示器：起点指示器、搜索指示器
>
> 两个互补区

### 2、单词符号的识别——超前搜索

单词符号识别的简单方法：超前搜索

> 识别关键字时需要多读后面的一些字符，以区分不同的语法
>

用到超前搜索的场景：

> :one: 标识符的识别
>
> :two: 常数的识别
>
> :three: 算符和界符的识别
>
> > 如c++中的++和--

### 3、状态转换图

**转换图**：是一张**有限方向图**（允许有环），结点表示状态、用圆圈表示；状态之间用箭弧连接。箭弧上的标记（字符）代表在射出结点状态下可能出现的输入字符或字符类

**功能**：识别一定的字符串

**初态**：一张状态图的启动条件，至少有一个，用圆圈表示

**终态**：一张状态图的结束条件，至少有一个，用双圈表示

*****：表示多读进了一个字符（超前搜索）

![image-20220228084125703](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220228084125703.png)

**a）图表示**：在状态1下，若输入字符为X，则读进X，并转换到状态2；若输入字符为Y，则读进Y，并转换到状态3；这并不是一个完整的状态图（没有终态）

**b）图表示**：状态0开始,若在状态0之下输人字符是一个字母,则读进它,并转人状态1。在状态1之下,若下一个输入字符为字母或数字,则读进它,并重新进入状态1。一直重复这个过程，直到状态1发现输人字符不再是字母或数字时(这个字符也已被读进)就进入状态2。状态2是终态,它意味着到此已识别出一个标识符,识别过程宣告终止。终态结上打个星号意味着多读进了一个不属于标识符部分的字符,应把它退还给输人串。如果在状态 0时输入字符不为“字母”,则意味着识别不出标识符,或者说,这个转换图工作不成功。

### 4、状态转换图的实现

程序化所需要的变量和过程：

:one:  **ch**	字符变量,存放最新读进的源程序字符。

:two:  **strToken**	字符数组,存放构成单词符号的字符串。

:three:  **GetChar**	子程序过程,将下一输入字符读到ch中,搜索指示器前移一字符位置。

:four:  **GetBC**	子程序过程，检查 ch 中的字符是否为空白。若是，则调用 CetChar直至 ch 中进人一个非空白字符。

:five:  **Concat**	过程,将ch中的字符连接到strToken之后。例如,假定strToken原来的值为“AB”,而ch中存放着'C',经调用Concat后,strToken的值就变为“ABC”。

:six:  **IsLetter和 IsDigit**	布尔函数过程，它们分别判断ch中的字符是否为字母和数字。

:seven:  **Reserve**	整型函数过程,对 strToken 中的字符串查找保留字表,若它是一个保留字则返回它的编码,否则返回0值(假定0不是保留字的编码)。

:eight:  **Retract**	子程序过程,将搜索指示器回调一个字符位置,将 ch 置为空白字符。

:nine:  **InsertId**	整型函数过程,将stToken中的标识符插人符号表,返回符号表指针。

:zero:  **InsenConst**	整型函数过程,将stroken中的常数插人常数表,返回常数表指针。

这些函数和子程序过程都不难编制。使用它们能够方便地构造状态转换图的对应程
序。一般来说,可让<mark>**每个状态结点对应一程序段**</mark>

对于不含回路的分叉结点来说,可让它对应一个swich语句或一组if…then…else语句。终态结点一般对应turn(code,value)语句，其中code为单词种别编码，vlue是字符数组的strToken（或者是一个整数值，或者无定义）。具体见后面实例。

为了**把状态图转换为程序**，每个状态需要建立一段程序，他要做的工作如下：

:one: 从输入缓冲区中取一个字符，为此需要使用函数**GetChar**，每次调用它，推进先行指针，送回1个字符。

:two: 确定在本状态下，哪一条箭弧是用刚刚来的输入字符标识的。如果找到，控制就转到该弧所指向的状态；若找不到，那么寻找该单词的企图就失败了。

:x: 失败：先行指针必须重新回到开始指针处，并用另一状态图来搜索**另一单词**。如果所有的状态转换图试过之后，还没有匹配的，就表明这是个**词法错误**，此时调用错误校正程序

**举例**

以下为case语句及其对应的状态图

```fortran
state i: GetChar;
		 Case ch OF
		 'A'--'Z':…… state j ……;
		 '0'--'9':…… state k ……;
		 '/'     :…… state l ……;
		 END;
		 Fail()
```

![image-20220305205636425](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305205636425.png)

**示例**

将状态结点对应于一段程序

![image-20220305205758429](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305205758429.png)

```fortran
state0: C:=GetChar;
		if IsLetter(C) then goto state 1
		else Fail();
		/*Fail()是子程序，它移动先行指针，开始下一个状态转换图，或者调用出错程序*/
state1: C:=GetChar;
		if IsLetter(C) or IsDigit(C)
            then goto state 1
        else if Delimiter(C)/*是过程，只要碰到标识符后的分界符，它返回TRUE*/
            	/*分界符一般为空格、算数、逻辑符号、括号、"="、";"、","、"."、","*/
            them goto state 1
        else Fail();
state2: Retract();/*将超前搜索的字符回调一个*/
		return(&id, Install());/*判断是否为保留字，所有的保留字，一字一码*/
```

如果要同时识别标识符和定义符，则需要修改state2

```fortran
state2: Retract();
		C := Reserve();/*对strToken 中的字符串查找保留字表,若它是一个保留字则返回它的编码,否则							返回0值(假定0不是保留字的编码)。*/
        if C = 0
          then return(&id, Install())
        else return(C,_) 
```

词法分析方法的步骤如下

:one: 给出程序设计语言的单词规范（单词表）

:two: <mark>对照单词表设计识别该语言所有单词的状态转换图</mark>

:three: 根据状态转换图编写词法分析程序

> 手动方法效率低

所以需要自动化方式

## 2.3 正规表达式和有限自动机

### 1、预备知识

字母表是一个非空有限集合，用$\sum$表示

字母表中的元素称为该字母表中的字母，或者符号，或者字符

字母表两个特性：非空性、有穷性

字符两个特性：整体性（不可分性）、可辨认性（可区分性）

字母表的乘积:$\sum _1 与 \sum_2$的乘积记作
$$
\sum_1\sum_2=\{ab|a\in \sum_1,b\in\sum_2\}
$$
**字母表的幂**：

> :one: $\sum^0=\{\varepsilon\},\ 其中\varepsilon是由\sum中的0个字符组成的$
>
> :two: $\sum ^n=\sum^{n-1}\sum,n\ge 1$

**字母表的闭包**：

:one: $\sum 的正闭包(positive\ closure)：\sum^+=\sum \cup \sum^2\cup\sum^3\cup……$

:one: $\sum 的克林闭包(Kleene\ closure)：\sum^*=\sum ^0 \cup \sum^+=\{\varepsilon\} \cup\sum ^+$

**句子**

> 句子：字符串对于任何$x\in \sum ^*$，x即$\sum$上的一个句子（sentence）
>
> 句子又可被称为字（word），字符行/符号行或者字符串/符号串

程序设计语言的单词规范——**单词表**可以与**正规集**建立起一一对应关系，进而与**正规式**建立起一一对应关系

### 2、正规式与正规集

$\sum^*的子集U,V$

> 积：		       $UV=\{\alpha\beta|\alpha\in U\ \& \ \beta \in V\}$
>
> n次积：	     $V^n=VVV...V\qquad V^0=\{ \varepsilon\}$
>
> V的闭包：      $V^*=V^0\cup V^1 \cup V^2 \cup……$
>
> V的正则闭包   $V^+=V\ V^*$

对于字母表$\sum$,我们感兴趣的是它的一些特殊字集,即所谓正规集。我们将使用正规式这个概念来表示正规集。下面是正规式和正规集的递归定义：

:one: $\varepsilon$和$\empty$都是$\sum$上的正规式,它们所表示的正规集分别为$\{\varepsilon\}$和 $\empty$;

:two: 任何 $a\in \sum$ 是 $\sum$ 上的一个正规式，它所表示的正规集为$\{a\}$；

:three: 

| 正规式  | 正规集          |
| ------- | --------------- |
| $U$     | $L(U)$          |
| $V$     | $L(V)$          |
| $(U|V)$ | $L(U)\cup L(V)$ |
| $(U*V)$ | $L(U)L(V)$      |
| $(U)^*$ | $L(U)^*$(闭包)  |

仅由有限次使用上述三步骤而得到的表达式才是 Σ上的正规式。仅由这些正规式所表示的字集才是 ∑上的正规集。

**举例**

> :one:	 令 $\sum =\{a,b\}$,下面是$\sum$上的正规式和相应的正规集：
>
> | 正规式                  | 正规集                                              |
> | ----------------------- | --------------------------------------------------- |
> | $ba^*$                  | Σ上以b为首，并且后跟任意多个a的字，{b，ba，baa，……} |
> | $a(a|b)^*$              | Σ上所有以a为首的字                                  |
> | $(a|b)^*(aa|bb)(a|b)^*$ | Σ上所有含有两个相继的a或两个相继的b的字。           |
>
> :two: 令$\sum =\{A,B,0,1\}$​,则
>
> | 正规式          | 正规集          |
> | --------------- | --------------- |
> | (AIB)(AIBI0I1)* | Σ上标识符的全体 |
> | (0\|1)(0\|1)*   | Σ上数的全体     |

<mark>如果两个正规式生成的正规集是一样的，那么这两个正规式是等价的,，记作U=V</mark>

**正规式上的运算律**

> 令U、V和W均为正规式,显而易见,下列关系普遍成立：
> :one: $U|V=V|U(交换律)$
>
> :two: $U|(V|W)=(U|V)|W(结合律)$
>
> :three: $U(VW)=(UV)W(结合律)$
>
> :four: $U(V|W)=UV|UW(分配律)$
>
> :five: $(V|W)U= VU|WU$
>
> :six: $\varepsilon U= U\varepsilon = U (吸收率)\qquad	\varepsilon表示空字符串$

> $\varepsilon$是一个字，但不是字符，是一个正规式
>
> $\emptyset$是一个集合，也是一个正规式
>

### 3、确定有限自动机（DFA）

一个`确定有限自动机(DFA)`M是一个五元式
$$
M=(S,\sum,\delta,s_0,F)
$$
其中
:one: $S$是一个<mark> 有限集</mark>，它的每个元素称为一个<mark>状态</mark>.。

:two: $\sum$是一个<mark>有穷字母表</mark>，它的每个元素称为一个<mark>输入字符</mark>。

:three: $\delta$是一个从$S\times \sum$至$S$的单值部分映射。$\delta (s,a)=s'$意味着：当现行状态为s、输人字符为a时,将转换到下一状态$s'$，我们称$s'$为s的一个后继状态。

:four: $s_0\in S$是唯一的<mark>初态</mark>

:five: $F\subseteq S$，是一个<mark>终态集</mark>（可空）——可能是某个DFA的一部分

显然，一个DFA可用一个矩阵表示,该矩阵的行表示状态,列表示输人字符,矩阵元素表示$\delta (s,a)$的值。这个矩阵称为<mark>状态转换矩阵</mark>。例如,有DFA

**举例**

> 有DFA , $M=(\{0,1,2,3\},\{a,b\},\delta,0,\{3\})$
>
> 其中$\delta$为
>
> $\delta(0,a)=1\qquad \delta(0,b)=2$
>
> $\delta(1,a)=3\qquad \delta(1,b)=2$
>
> $\delta(2,a)=1\qquad \delta(2,b)=3$
>
> $\delta(3,a)=3\qquad \delta(3,b)=3$
>
> 对应的状态转换矩阵如下:
>
> | 状态 | a    | b    |
> | ---- | ---- | ---- |
> | 0    | 1    | 2    |
> | 1    | 3    | 2    |
> | 2    | 1    | 3    |
> | 3    | 3    | 3    |

一个DFA也可表示成一张(确定的)**状态转换图**。假定DFA M 含有 m 个状态和 n 个**输入字符**,那么,这个图含有 m 个**状态结点**,每个结点**顶多有n条**箭弧射出和别的结点相连接,每条箭弧用$\sum$中的一个不同输人字符作标记,整张图含有唯一的一个**初态结点**和若干个(可以是0个)终态结点。

上例转换为状态转换图为：

![image-20220305215236682](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305215236682.png)

对于$\sum^*$中的任何字α,若存在一条从初态结点到某一终态结点的通路,且这条通路上所有弧的标记符连接成的字等于α,则称α可为 DFA M<mark>所识别(读出或接受)</mark>。若 M 的初态结点同时又是终态结点，则空字。可为 M 所识别(或接受)。DFA M 所能识别的字的全体记为L(M)。

**举例：数字常量的正则表达式对应的DFA**

> digit = [0-9] /*数字0-9*/
> nat = digit^+^ /*无符号整数*/
> signedNat = (+ | -)?nat /*有符号整数*/
> number = signedNat("."nat)? /*一般的数字*/
> 
> ![image-20220305220759370](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305220759370.png)

> 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。
>
> 例如：
>
> - **yjq^+^b**，可以匹配 **yjqb、yjqqb、yjqqqqb** 等，**+** 号代表前面的字符必须至少出现一次（1次或多次）。
> - **yjq\*b**，可以匹配**yjb、yjqb、yjqqb、yjqqqqb** 等，***** 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。
> - **yj?q** 可以匹配 **yq** 或者 **yjq**，**?** 问号代表前面的字符最多只可以出现一次（0次或1次）。

**举例：区分只有一个和包含最多一个**

![image-20220305222228325](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220305222228325.png)



如果一个DFA M的输入字母表为Σ,则我们也称M是Σ上的一个DFA。可以证明：
**$\sum$上的一个字集V真包含于$\sum ^*$是正规的,当且仅当存在Σ上的DFAM,使得V=L(M)。**

> 不能是包含于，否则是无限的

DFA的<mark>确定性</mark>表现在映射$\delta：S×Σ→S$是一个**<mark>单值函数</mark>**。也就是说,对任何状态$s\in S$和输入符号$ a∈Σ$，$\delta(s,a)$唯一地确定了下一状态。从转换图的角度来看,假定字母表Σ含有 n 个输人字符,那么,任何一个状态结最多只有 n 条弧射出,而且每条弧以一个不同的输入字符标记。如果也允许$\sum$是一个多值函数,我们就得到非确定自动机的概念。

### 4、非确定有限自动机（NFA）

#### NFA的定义

一个`非确定有限自动机(NFA)`M是一个五元式
$$
M=(S,\sum,\delta,S_0,F)
$$
其中
:one: $S$是一个<mark> 有限集</mark>，它的每个元素称为一个<mark>状态</mark>.。

:two: $\sum$是一个<mark>有穷字母表</mark>，它的每个元素称为一个<mark>输入字符</mark>。

:three: $\delta$是一个从$S\times \sum^*$至$S$的子集的映射。$\delta：S\times \sum^*\rightarrow 2^S $

:four: $S_0\subseteq S$是一个非空<mark>初态集</mark>

:five: $F\subseteq S$，是一个<mark>终态集</mark>（可空）——可能是某个DFA的一部分

显然，一个含有 m个状态和n个输入字符的NFA可表示成如下的状态转换图：该图含有 m个状态结点,每个结点**可射出若干条箭弧**与别的结点相连接,每条弧用 $\sum ^*$中的一个字(**不一定要不同的字而且可以是空字 **)作标记(称为输人字),整张图至少含有一个初态结点以及若干个(可以是 0个)终态结点。某些结点既可以是初态结点也可以是终态结点。

对于$\sum ^*$中的任何一个字α,若存在一条从某一初态结点到某一终态结点的通路,且这条通路上所有弧的标记字依序连接成的字(忽略那些标记为ε的弧)等于α,则称α可为NFA M **所识别**(读出或接受)。若M的某些结点既是初态结点又是终态结点,或者存在条从某个初态结点到某个终态结点的ε通路,那么,空字ε可为M所接受。

> 箭弧上是一个串或者空字的是NFA

**举例：下图所示的状态转换图的$S、\sum、\sum^*$**如下

> $S=\{x,1,2,3,4,5,6,y\}$：x，y表示NFA的初态结点和终态结点只有一个
>
> $\sum=\{a,b\}$
>
> $\sum ^*=\{\alpha|\alpha为ε，或者为a、b的任意组合\}$
>
> ![image-20220311211128802](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220311211128802.png)

![image-20220311204803165](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220311204803165.png)

从状态图看NFA和DFA的区别

> NFA可以有多个初态；弧上的标记可以是一个字（甚至是正规式），而不一定是单个字符；同一个字可能出现在同状态射出的多条弧上
>
> DFA是NFA的特例
>
> |            | NFA             | DFA  |
> | ---------- | --------------- | ---- |
> | 初始状态   | 不唯一          | 唯一 |
> | 弧上的标记 | 字（单字符，ε） | 字符 |
> | 转换关系   | 非确定          | 确定 |

#### ε_CLOSURE(I)的定义

假定I是NFA M的状态集的一个子集，定义ε_CLOSURE(I)如下：

:one: $若s\in I,则s\in ε\_CLOSURE(I)$：状态子集中的每一个元素都是闭包中的元素

:two: 若$s\in I$,那么从s出发经任意条ε弧而能到达的任意状态s'都属于ε_CLOSURE(I)

状态集ε_CLOSURE(I)称为I的ε闭包

#### Ia的定义

假定I是NFA M的状态集的一个子集。$a\in \sum$，定义
$$
I_a=ε\_CLOSURE(J)
$$
其中，J是那些可以从I中的某一个状态节点出发经过一条a弧而到达的状态节点的全体

#### 子集算法【重点】

使用子集法将非确定有限自动机（NFA）转换为确定有限自动机(DFA)时首先要引入状态节点 X，其目的是否为解决初态节点惟一性

:one: 表的初始化

> $\sum = \{a_1,a_2,...,a_k\}$,先构造一张表，该表每行含有k+1列。置该表的首行首列为$ε\_CLOSURE(x)$

:two: 处理表的一行

> 如果某一行的第一列的状态子集已经确定，例如记作I，那么，求出这一行的第二个和第三个子集Ia和Ib看它们是否已经在表的第一列出现，将未出现的**填入**到后面空行的第一列

:three: 重复处理

> 重复上述过程，直到所有第二列和第三列的所有状态子集均已经在第一列中出现

**举例：将下图的NFA按照上述证明过程进行DFA化**

![image-20220311211303125](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220311211303125.png)

| I                 | Ia               | Ib               |
| ----------------- | ---------------- | ---------------- |
| {x,5, 1}          | {5,3, 1}         | {5, 4, 1}        |
| {5,3, 1}          | {5,3, 1,2,6, Y}  | {5,4, 1}         |
| {5,4, 1}          | {5,3, 1}         | {5,4, 1,2, 6, Y} |
| {5,3, 1,2, 6, Y}  | {5,3, 1,2, 6, Y} | {5,4, 1,6, Y}    |
| {5,4, 1,6, Y}     | {5,3, 1,6,Y}     | {5, 4, 1,2, 6,Y} |
| {5, 4, 1,2, 6, Y} | {5,3, 1,6,Y}     | {5,4, 1,2,6, Y}  |
| {5,3, 1,6, Y}     | {5,3, 1,2,6, Y}  | {5,4, 1,6, Y}    |

> 以第一行Ia为例：初始子集为I={x,5,1},从I中的某一个状态节点出发经过一条a弧而到达的状态节点的全体为{5，3}，在这个子集的基础上的空字闭包为{5,3,1}，所以Ia为{5，3，1}

对上图的表格中的所有子集进行重命名，可以得到新的状态转换矩阵，从而得到相应的DFA，如图所示

| s    | a    | b    |
| ---- | ---- | ---- |
| 0    | 1    | 2    |
| 1    | 3    | 2    |
| 2    | 1    | 5    |
| 3    | 3    | 4    |
| 4    | 6    | 5    |
| 5    | 6    | 5    |
| 6    | 3    | 4    |

![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220519173129583.png)

## 2.4 正规文法与有限自动机的等价性

对于正规文法 G 和有限自动机 M,如果 L(C)= L(M),则称 G 和M 是等价的。关于正规文法和有限自动机的等价性,有以下结论：

:one: 对每一个右线性正规文法 G或左线性正规文法 G，都存在一个有限自动机（FA）M,使得L(M)=L(G)。

:two: 对每一个 FA M,都存在一个右线性正规文法 GR和左线性正规文法 G.使得L(M)=L(GR)=L(GL)。

## 2.5 正规式与有限自动机的等价式

:one: 对任何FA M,都存在一个正规式r,使得L(r)=L(M)。

:two: 对任何正规式 r,都存在一个 FA M,使得 L(M)= L(r)。

## 2.6 确定有限自动机的化简

一个DFA M的化简是指：寻找一个状态数比M少的DFA M'，使得L(M)=L(M')。

一个DFA M的状态最少话过程旨在将M的状态集分割成一些不相交的子集，使得任何不同的两个字集中的状态都是可区别的，而同一子集中的任何两个状态都是等价的

考虑如下DFA的化简

![image-20220519173129583](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220519173129583.png)

:one: 先按照终态和非终态分组：终态组{3，4，5，6}和非终态组{0，1，2}

:two: 检查一步转移（后继状态）

|              | a      | b      |
| ------------ | ------ | ------ |
| {0，1，2}    | {1，3} | {2，5} |
| {3，4，5，6} | {3，6} | {4，5} |

:three: {3，6}和{4，5}**包含于**{3，4，5，6}，所以{3，4，5，6}不需要划分；但是{1，3}和{2，5}不包含于{0，1，2}，观察后继状态，状态1经过a弧到达状态3，而状态0，2经a弧到达状态1，所以分成{1}，{0，2}

:four: {1}只有一个元素，不需要继续检查，只用继续检查{0，2}，0经过b到2，2经过b到5，继续分割为{0}，{2}

:five: 所以最终的划分为{3，4，5，6}，{0}，{1}，{2}

将状态3代表{3，4，5，6}，化简的状态转换图如下：

![image-20220311214018758](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220311214018758.png)

## 参考资料

[1] 西安交通大学软件工程专业编译原理 吴晓军 2022春

[2] 陈火旺，刘春林，谭庆平，赵克佳，刘越. 程序设计语言编译原理（第3版）. 北京：国防工业出版社，2010/20132017
