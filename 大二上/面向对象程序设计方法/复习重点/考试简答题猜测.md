### 面向对象概念与简答

**1、面向对象的三大特征是什么？**

封装、继承、多态

**2、简述一下封装的定义以及封装的好处?**

封装就是将对象的数据和基于数据的操作包装成独立性很强的模块，将不需要对外公开的数据和操作进行私有化定义，外界如果要访问对象内部的私有数据可以通过一些公有化操作进行获取。

封装具有以下几个好处：良好的封装减少了耦合；同时增强了数据的安全性，无法直接改变私有属性的值；隐藏了内部实现细节，便于修改与代码重用。

**3、简述一下继承的定义与实现**

继承是在当前类的基础上创建新类，并添加新的属性和方法。Java通过关键字extends实现子类继承父类。

**4、简述一下多态的定义与原理**

多态即在一个继承关系的程序中允许同名的不同方法共存，多态有三个必要的条件：继承、重写、父类指向子类对象。

在继承关系下，利用向上转型，子类的对象转化为父类的对象，与动态绑定相结合，通过父类对象调用具有相同名称的子类方法，JVM能够自动分辨出对象用的方法所属的子类，从而调用相应子类的方法。

**5、Java的执行机制**

首先编写源代码(.java文件)，然后编译器将源代码编译成字节码文件(.class文件)，之后JVM中的类加载器加载字节码文件，JVM中的执行引擎找到入口方法main()，执行其中的方法。

**6、构造方法的定义与特点**

**构造方法**，专门用于对象的初始化，是一种以类名来命名的特殊方法，没有返回值，可以带参数或不带参数，一个类都可以有多个构造方法。

**特点**，

**1) ** 一种和类同名的特殊方法，一个类中可以有多个构造方法。
**2)**  用来完成对象的初始化工作。
**3**)  无返回类型、无修饰符void,通常被声明为公有的(public)。
**4)**  一个构造方法可以有任意多个参数。
**5) ** 不能在程序中显式调用，在生成一个对象时，系统会自动调用该类的构造方法。
**6) ** 如果没有写构造方法，系统会自动提供一个默认构造方法`Classname(){}`。
**7)**   一旦类中已有带参数的构造方法，系统则不会再提供默认构造方法。

**7、简述函数中的参数传递方式**

在Java语言中，**基本数据类型作为参数时，均采用传值( passing-by-value)的方式完成**，对形参的任何改动都不会影响到实参。而**引用类型变量作为参数传递时，采用的是引用传递( passing-by-reference)的方式，在方法体中对形参的改动将会影响到实参**。

然而String类型虽然属于引用类型，但作为参数时采用的是**传值方式**来完成。

**8、说明java变量的分类**

java中包含三种变量：实例变量、静态变量与局部变量。

**实例变量**是处在类中，方法外的变量，从属于类，由类生成对象时，才分配存储空间。**静态变量**是使用static修饰的变量，一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间，存储在JVM的方法区。**局部变量**是声明在方法、构造方法或者语句块中的变量，存储在JVM的栈中。

**9、简述static关键字的使用**

static关键字有三个用途：

**static方法**一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，直接用类名.静态方法就可以使用，因此对于静态方法来说，是没有this的。

**static变量**不属于某个对象，不能通过某个对象来引用，在声明前加上static关键字，属于类范围，储存在JVM的方法区中。

**static代码块**可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

**10、简述final关键字的使用**

final修饰符可以用在数据成员、方法、类之前，这意味着是一种终结状态。

final 在类之前:表示该类是终结类，不能再被继承。如String和StringBuffer就是终结类，不能被继承。

final在方法之前:表示该方法是终结方法，该方法不能被任何派生的子类覆盖。

final在变量之前:表示变量的值在初始化之后就不能再改变，相当于定义了一个常量。

**11、简述抽象类与抽象方法**

用abstract关键字来修饰一个类，这个类叫做抽象类。
用abstract来修饰一个方法，该方法叫做抽象方法。

抽象方法：只有方法的声明，没有方法的实现。

抽象类不能被实例化，只能作为父类被继承，如果一个类中包含抽象方法，其一定要被abstract修饰。

**12、说明接口与抽象类的异同**

接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

抽象类和接口在定义方面有一定的相似性，都具有抽象方法，抽象方法的实现都放在其他类中实现。二者的最大区别在于抽象类除了有抽象方法外还可以有一般方法的实现，而接口除了允许静态和默认方法外。只能是”纯抽象方法“。接口方法必须是public的，而抽象类中的方法可以是除private以外的其他类型。

**13、简述一下this的使用**

this表示的是自身的一个对象，代表对象本身，即一个指向自身的指针，this在Java中主要有三个用途，1、普通的直接引用，表示的就是当前对象本身；2、当形参和成员变量重名时利用this进行区分；3、利用this可以引用当前类的其他构造方法。

**14、简述一下super的使用**

super表示的是指向离自己最近的一个父类对象的指针，super也有三个主要的用途，1、普通的直接引用，super指向了当前对象的父类，因此可以利用super.xxx来调用父类的成员；2、当子类的成员变量或方法与父类中的变量或方法重名时，可以利用super进行区分；3、利用super引用父类的构造方法，super(参数)可以调用父类中的某个参数一致的构造方法，这条语句应该放在构造函数中的第一条语句。

每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

**15、说明一下super与this的异同**

:one: 指向不同：super指向的是离当前类最近的一个父类对象，而this表示的是当前对象

:two: 调用的构造方法不同，super(参数)表示调用最近父类中的某一个构造函数; this(参数)表示调用本类中另一种构造函数，但都需要方法构造函数中的第一条。

:three: this和 super都指的是对象，所以，均不可以在 static 环境中使用

:five: 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字

**16、说明比较一下类的访问控制修饰符**

Java中一共有四种访问修饰符：private、default(什么都不写）、protected与public，分别表示不同的访问权限。类的访问控制只有public和默认两种，而类成员则包括了以上四种，其不同的涵义如下。

1、public：对所有类可见

2、protected：对同一个包中的类、同一个类以及子类可见

3、default：仅对同一个包中类可见

4、private：仅对同一个类可见，类外不可见

**17、比较String与StringBuffer类的异同**

String类与StringBuffer类都是Java提供的处理字符串的类，二者都是final类，不可被继承。

两者的内部实现方式不同，String 类对象创建后再更改就产生新对象，而StringBuffer 类的对象在创建后，可以改动其中的字符，这是因为改变字符串值时，只是**在原有对象存储的内存地址上进一步操作，不生成新对象，内存使用上比String有优势，比较节省资源**。所以在实际开发中，如果经常更改字符串的内容，比如**执行插入、删除等操作，使用StringBuffer更合适些**，但StringBuffer不支持单个字符检索或子串检索。

**18、说明重写（override）的定义与要求**

重写是子类对父类的允许访问的方法的实现过程进行重新编写。要求：

:one: 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表

:two: 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型

:three: 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限，子类不能重写父类中声明为private权限的方法

:four: 子类方法抛出的异常不能大于父类被重写方法的异常

**19、说明重载（overload）的定义与规则**

重载(overloading) 是**在一个类里面**，方法名字相同，而参数不同。返回类型可以相同也可以不同。规则：

:one: **被重载的方法必须改变参数列表(参数个数或类型不一样)；**

:two: **被重载的方法可以改变返回类型；**

:three: **被重载的方法可以改变访问修饰符；**

:four: **被重载的方法可以声明新的或更广的检查异常；**

:five: **方法能够在同一个类中或者在一个子类中被重载。**

:six: **无法以返回值类型作为重载函数的区分标准。**

**20、说明重写和重载的区别**

方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，**重写是父类与子类之间多态性的一种表现，重载可以理解成同一个类中多态的具体表现形式。**

| 区别点   | 重载方法 | 重写方法                                                     |
| :------- | :------- | :----------------------------------------------------------- |
| 参数列表 | 必须修改 | 一定不能修改                                                 |
| 返回类型 | 可以修改 | 一定不能修改（看java版本，高版本可修改成父类返回值的派生类） |
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常               |
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）                       |

**21、说明is-a关系与has-a关系**

is-a关系是继承的体现，A类is a B类，我们就可以说A类继承自B类，用extends关键字来加以实现；而has-a关系是组合的体现，可简单理解为一个类里包含了另一个类的对象，例如一辆车和其中的轮子就属于组合关系，也就是可以说car has a wheel。

在组合关系下，A类使用B类时，B类的对象不仅可以作为A类数据成员，还常常作为参数传递给A类的方法。在更多的时候，组合比继承更能使系统具有高度的灵活性和稳定性，有助于提升整个系统的可重用性，因此设计时可以优先考虑组合。

**22、说明Java的异常分类**

Java的异常在总体上可以分为两类：非检查型异常和检查型异常。**非检查型异常**继承自RuntimeException，这类检查不需要检测的，由系统自动检测出异常，自动报错，提供默认的异常处理程序,常见的有数组越界、除零异常等。**检查型异常**要求用户程序必须处理，属于**Exception类及其子类**，需要手动标示在什么位置可能出现异常、如何捕获异常以及如何处理。

**23、简述java异常处理机制**

根据具体情况判断在代码段何处处理异常，处理方式包括两种：**捕获异常和声明抛出异常**。对于前者，使用try-catch语句，捕获到发生的异常，并进行相应的处理；对于后者，不在当前方法内处理异常，而是把异常抛出到调用方法中由上层方法处理

**24、说明throw和throws的区别**

throws与throw仅一个字母的差别，却是两种完全不同的概念。throws写在方法的后面,抛出异常交给上级方法或类，即抛给调用它的方法进一步处理; 而throw多用来抛出自定义的异常类对象，这类异常必须是Throwable类的子类，需要用户自己手工进行捕获。

