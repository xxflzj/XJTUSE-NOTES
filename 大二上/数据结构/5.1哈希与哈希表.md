

# [XJTUSE]数据结构学习——散列（哈希）

![[XJTUSE]数据结构学习——散列（哈希）](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/af229e0a24124ac87b09768b3e534387.png)

## Hashing(散列)

是对直接寻址法的一种改进

这是一个技术，通过它将直接寻址中的关键字通过一个“黑盒子”，把其值压缩到另外一个范围中的某个地址值

平均情形下获得**常数级别的查找数据和储存数据的时间**

## Hash Function(哈希函数)

接收待查找的关键字

返回一个数组中的索引

> 这个索引就是储存关键字所对应纪录数组中的储存位置，称这个数组为**Hash Table**，称HashFunction返回的索引值为**Hash lndex**
>
> :label: **哈希表是一个数组，哈希函数返回的是哈希表的索引值**

**完美哈希函数**

> 该函数能够将查找的关键字映射到互不相同的哈希表上的哈希索引忠
>
> 但是基本不存在此类函数

## 示例

![image-20220126113056818](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20220126113056818.png)

在找关键字为555-1214这个关键字的位置的时候，没有用到比较，不用从哈希表中一个一个去比，通过将关键字**用哈希函数运算**出一个值，这个值就是关键字为555-1214在哈希表中的索引位置

## 映射

如何通过哈希函数将待查关键字和哈希表的索引号进行映射？

> 可以通过取模运算

如果关键字不是整数类型，我们可以将不是整数类型的关键字通过各种方式转换成整数类型，转换后的结果称之为**hash code**

### 数字分析法

假设关键字集合中的每个关键字都是由s位数字组成(k1,k2,..., kn)，分析关键字集中的全体，并从中提取分布均匀的若干位或它们的组合作为地址

```
H(key)=(last 7 digits of key) % n
```

> 比如:出生年月日
>
> 仅限于
>
> > 能预先估计出全体关键字的每一位上各种数字出现的频度
> >
> > 关键字中的某几部分总是相等的

### 平方取中法

若关键字的每一位都有某些数字重复出现频度很高的现象，则先求关键字的平方值，以通过“平方”扩大差别，同时平方值的中间几位受到整个关键字中各位的影响

```
H(key) = (middle N digits of key^2) % n
```

### 哈希函数构建

:one: 使哈希函数尽可能的完美

:two: 采用何种构造哈希函数的方法取决于建表的关键字集合的情况(包括关键字的范围和形态)，总的原则是**使产生冲突的可能性降到尽可能地小**

:three: 要计算容易和速度快

:four: 确定性:对于同一个关键码，不管什么时候计算出来的hash index都应该是确定的

:five: 散列函数的定义域必须包括需要存储的全部关键码，如果散列表允许有m个地址时，其值域必须在0到m-1之间

## Hash冲突

**哈希冲突**：不同的关键字通过哈希函数运算后得到哈希索引一致，就会引起哈希冲突

解决办法如下

### 开地址法（open addressing）

在哈希表中重新找一个位置

#### 线性探查（linear probing）

如果在哈希表中的第k个位置发生了冲突，那么就依次试探其后继位置k+1，k+2...

> 会产生基本聚集

![image-20220127204942796](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20220127204942796.png)

##### <mark>**DEMO**</mark>

假设给出一组表项，它们的关键码为Burke,Eat, Bird， Blue,Art, Alert, Height, Eight.采用的散列函数是:**取其第一个字母在字母表中的位置**，散列表的长度为26，试采用线性探查法处理冲突，给出散列表的结果

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20220127210134006.png" alt="image-20220127210134006" style="zoom: 67%;" />

##### 性能分析

:one: 搜索成功的平均搜索长度ASLsucc

> 指的是找到表中已有表项的平均探查次数
>
> 如上图，其$ASL_{succ}=\frac{1}{8}\sum^8_{i=1}=\frac{1}{8}(1+1+2+3+1+6+3+1)=\frac{9}{4}$
>
> :label: 分母是已有关键字个数

:two: 搜索不成功的平均搜索长度ASLunsucc

> 指在表中搜索不到待查表项，但找到插入位置的平均探查次数,它是表中**所有可能散列到的位置上要插入新元素时为找到空桶**的探查次数的平均直
>
> 到空位置才能明确
>
> 如上图，其$ASL_{unsucc}=\frac{9+8+7+6+5+4+3+2+18}{26}=\frac{31}{13}$
>
> :label: 还要算剩下的18个位置的
>
> :label: 分母是散列表长度

BST的有序性比散列表强

##### 需要注意的问题

:one: 不能真正删除表中已有表项，删除表项会影响其他表项的搜索

> :label: 若把关键码为Bird的表项真正删除，把它所在位置的info域置为Empty，以后在搜索关键码为Blue 和Eat的表项时就查不下去，会错误地判断表中没有关键码为Blue 和Eat的表项

:two: 若想删除一个表项,只能给它做一个**删除标记deleted**进行逻辑删除,不能把它真正删去

> 逻辑删除的副作用是:在执行多次副除后,表面上看起来散列表很满,实际上有许多位置没有利用

:three: 线性探查方法容易产生“堆积”，不同探查序列的关键码占据可用的空桶,为寻找某一关键码要经历不同的探查序列,导致搜索时间增加

> 在某一个范围内的数据聚集。

#### 平方探查（quadratic probing）

如果在哈希表的第k个位置发生了冲突，那么就依次试探其后继位置k+1^2、k+2^2、k+3^2...

如果在哈希表的第k个位置发生了冲突，那么就依次试探其后继位置k+1^2、k-1^2、k+2^2、k-2^2、k+3^2...

![image-20220127213221394](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20220127213221394.png)

相对于线性探测法，会产生二次聚集

> 散列表的长度尽可能定义为<mark>素数</mark>

**注意**

> 删除元素的问题如同线性探查一样，不能真删除元素，而应该打标记
>
> 如果有两个关键字值有相同的基位置，那么它们就会有同样的探查序列，这个问题称为二次聚集

#### 双散列探查（double hashing probing）  

当通过第一个哈希函数得到的哈希索引发生冲突之后，获得的下一个哈希索引应该是**第一个哈希索引加上通过第二个哈希函数求得的哈希索引之和**

对第二个哈希函数的要求

> **有别于第一个哈希函数**
>
> 所求的值也要依赖于关键字
>
> 不能返回0值

:label: 避免了基本聚集和二次聚集

![image-20220127215124144](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20220127215124144.png)

这种方法会使关键字的探查序列不同，从而避免了聚集

### 开散列法（open hashing）

Java API中的HashMap用到的就是开散列法。每一个桶是用红黑树实现的

改变哈希表 的结构，使哈希表的每一个位置上不再只容纳一个元素，而是可以容纳多个

哈希表中的每一个位置都不止代表一个元素,而可以代表多个

> 我们把能够代表多个元素的位置形象的称为桶
>
> 我们称同一子集（桶）中的关键码互为同义词

桶可以表示为

> 线性表、有序线性表等

![image-20220127221708475](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20220127221708475.png)

## 哈希效率衡量

### 装载因子

完美的哈希函数并不总是实际的，因此冲突的发生是不可避免的

为了能够度量哈希的效率，我们需要借用一个称为Load Factor的因子
$$
\lambda = \frac{N}{M} \qquad N:实际记录个数	\quad M：哈希表长度
$$

> 线性探查法：$\lambda<0.3$效率比较好
>
> 平方探查法或双哈希法：$\lambda <0.5$比较好
>
> 开散列法：$\lambda <1$比较好

## 参考资料

1. 西安交通大学软件工程  数据结构与算法PPT  原盛 

