# 系统分析与设计复习

基于监听方式的事件响应机制

![image-20211219202536239](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219202536239.png)

RBAC模型

![image-20211219202640273](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219202640273.png)

## 需求工程

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211218213739103.png" alt="image-20211218213739103" style="zoom:50%;" />

**需求的三个层次：**业务需求、用户需求和功能需求

与客户打交道的主要目的：
• 	一是获取明确需求(业务功能需求分析 + 心理需求分析)
•     二是签合同
•     三是顺利验收
•     四为未来的项目留下余地

什么是需求工程
–     把所有与需求直接相关的活动通称为需求工程。
–     需求工程中的活动可分为**两大类，一类属于需求开发，另一类属于需求管理**

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211218220821241.png" alt="image-20211218220821241" style="zoom:60%;" />

最后，需求分析员与被调查者建立联系，确定调查的时 间、地点、人员等，撰写需求调查计划。
–  特别留意: **不要漏掉典型的用户**。

需求获取重要工具——**上下文图**

**角色 ——》需求——》功能——》系统边界**

需求分析方法有两类： –  “问答分析法” –  “建模分析法”

候选流程反映了**系统的健壮性**，是区分系统设计好坏的一个前提

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219093446953.png" alt="image-20211219093446953" style="zoom:50%;" />

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219093618945.png" alt="image-20211219093618945" style="zoom:67%;" />

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219093824144.png" alt="image-20211219093824144" style="zoom:67%;" />

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219093852541.png" alt="image-20211219093852541" style="zoom:67%;" />

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219093930888.png" alt="image-20211219093930888" style="zoom:67%;" />

## 信息工程模型

**ADT**的形式化定义是三元组：ADT=(D，S，P)
–   其中：D是数据对象，S是D上的关系集，P是对D的基本操作 集。

> Key 键： 是一个属性（或一组 属性），它们对每个实体实例具 有唯一的值。 也称标识符。
> 复合键 Concatenated Key:    能 唯一地标识实体的一个实例的一 组属性， 也称组合键和合成键；
> 候选健 Candidate Key:     是一组 可以作为一个实体主健的健， 也 称候选标识符；
> 主键 Primary Key:  是最终用来 唯一标识或者确定一个实体实例 的候选键。
> 替代键 Alternate Key：      是没有 被选中作为主键的其它候选键。

信息世界也叫做观念世界，是现实世界在人们头脑中的反映。

> 客观世界中的事物在信息世界中叫做实体，反映事物之间联系的叫做 实体模型。
> 实体是由若干属性的属性值组成。
> 属性是实体某一方面的特征，相应于事物的性质。

数据世界则是信息世界中信息的数据化 ，现实世界中的事物及其联系在数据世 界中用数据模型描述。

> 描述每一实体的数据称为记录，描述属性的数据叫 做数据项或字段。
> 实体集相对应的称为文件。

### 数据库设计的主要工作

:one: 为开发一个系统所使用的数据库，在开始分析数据库的需求前 ，分析员必须了解该系统的总目标和范围。然后建立一个完整并高度细 化的信息模型:。
:two: 此信息模型应包括一个综合的数据词典，定义所有在开发数 据库时用到的数据项。
:three: 接着数据库分析定义数据库的逻辑特性和物理特性。
:four:  以信息模型和系统规格说明为指导，定义数据库的逻辑数据结 构。这种逻辑结构必须适应数据存取、修改、关联性及其它相关需求。
:five: 一旦逻辑数据结构建立起来，就可以研制数据库的物理结构 。物理数据库结构定义文件结构、记录格式、与硬件相关的处理方式以 及数据库管理系统的特性。
:six: 要对模式和物理特性进行完全的评审。

E-R图， 可定义一 个实体模型

#### 数据库规范化

(1) 表 格 中 每个信息项必须 是一个不可分割的数据项。
(2) 表 格 中 每 一 列 中 所 有 信 息项必须是同一类型，各 列的名字(属性名)互异， 列的次序任意。
(3)表格中各行互不相同， 行的次序任意。

:one: 第一范式

**定义**：数据库表中得所有字段都是单一属性，不可再分得，这个单一属性是由基本的数据类型构成的

第一范式要求数据库中的表都是二维表，表中不能有表

![image-20211219151602832](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219151602832.png)

:two: 第二范式

**定义**：数据库中的表中不存在非关键字对任意候选关键字段的部分函数依赖，即除了主键外，其他字段必须依赖主键。

> 首先就是符合第一范式。
>
> 表必须存在主键。
>
> 非主键列不能只依赖于主键的一部分

第二范式，理论概念是数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，不能部分依赖。听着抽象，翻译一下，应该包括了三层含义，

\1. 首先就是符合第一范式。

\2. 表必须存在主键。

\3. 非主键列不能只依赖于主键的一部分。

如下这张表，主键是“快递单号”和“商品编号”，但是像“价格”依赖于“商品编号”，“数量”依赖于“快递单号”，都是依赖于主键的一部分，这种情况，就是不符合第二范式的，

![aed285f7d00586a66573d9a748518082.png](https://img-blog.csdnimg.cn/img_convert/aed285f7d00586a66573d9a748518082.png)

因此，拆分为这三张表，快递信息表中都是和快递相关的字段，商品信息表中都是和商品相关的字段，快递项目表则是快递和商品的关联表，每张表中非主键列都依赖于主键的全部，此时，就是符合第三范式的，

![eacea7ecaa3f2ae7bca762d67ac0fc29.png](https://img-blog.csdnimg.cn/img_convert/eacea7ecaa3f2ae7bca762d67ac0fc29.png)

:three: 第三范式

定义：实体的非主属性的值不依赖于任何其它非主键属 性。注：所有非主属性对任何候选关键字都不存在传递依赖

非主属性相互独立，即任何非主属性间不存在函数依赖。

如下例子，“爸爸”是主键，但是“儿子的玩具车”和“儿子的玩具枪”依赖的是“儿子”，并不依赖于主键，存在传递函数依赖的关系，因此不符合第三范式，

![57ad8769aa65208ebce0377856986898.png](https://img-blog.csdnimg.cn/img_convert/57ad8769aa65208ebce0377856986898.png)

可以拆成这两张，每张表中的非主键字段，都只依赖于主键，不存在传递函数依赖的关系，因此这是符合第三范式的，

![4dae4292c48e994cab5d4ac3bca50dd5.png](https://img-blog.csdnimg.cn/img_convert/4dae4292c48e994cab5d4ac3bca50dd5.png)

#### 完整性约束

:one: **实体完整性**：关系的主码中的属性值不能为空值；空值：不知道或无意义的值；

:two: **域完整性**：是指表中的列必须满足某种特V定的数据类型约束 ，其中约束又包括取值范围、精度等规定。

:three: **参照完整性**：是指两个表的主键和外键的数据应一致，保证 了表之间的数据的一致性，防止了数据丢失或无意义的数据在 数据库中扩散。 建立永久关联图，并设计关联上的参照完整性 类型表。

:four: **用户定义的完整性**：不同的关系数据库系统根据其应用环境 的不同，往往还需要一些特殊的约束条件。用户定义的完整性 即是针对某个特定关系数据库的约束条件，它反映某一具体应 用必须满足的语义要求。

### 数据库常用语句

### 数据库常用语句

建立数据库

```
create database if not exists system;
```

建表

```sql
create table test(
	id int not null primary key, 
	name varchar(20) not null
	);
```

语法 create table 表名称( 字段名 字段名类型 字段描述符，字段名 字段类型 字段描述符);

删除表

```sql
drop table test;
```

插入语句

```sql
insert into test values(123,"1234");
```

查询语句

```sql
select * from test;
select test.id from test where test.name="123";
```

更新语句

```sql
update test set name="yjq" where id=123;
```

删除语句

```sql
delete from test where id=123;
```





## 数据流设计

数据流关键原则：边界/目标原则

数据流分析（Data Flow Analysis，简称 DFA）  方法是一种以数据流技术为基础的、自 顶向下、逐步求精的系统分析方法。是从用户视角下来审视数据被操作与流转的过程。

数据流图只反映**系统逻辑功能**

利用数据流图，可以表达数据在系统内部的逻辑流向以及系统的逻辑功能和数据的逻辑变换。

分层的数据流图总是由顶层、中间层和底层组成的（或：**上下文图**+0 级图+n 级图) ：

> ①     顶层数据流图确定了系统的边界
> ②     中层图描述了某个处理过程的分解，而组成部分要进一步被分解
> ③     底层图描述的是无须分解的基本处理过程 

DFD（数据流图）有如下设计思想：

> ①     DFD 数据流上下层之间的流入与流出数据一致
>
> ②     DFD 的核心特征是：自顶向下，逐步求精
> ③     DFD 数据流图与数据字典相结合
> ④     DFD 数据流上下层之间的流入与流出数据一致

其中上下文图定义了系统的边界，最重要

![image-20211219203928171](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219203928171.png)

**数据流图的基本组成**

外部项(外部实体)：外部项在数据流图中表示所描 述系统的数据来源和去处的各种实体或工作环节。
加工(数据处理)：又称数据处理逻辑，描述系统对 信息进行处理的逻辑功能。
数据存储：逻辑意义上的数据存储环节，即系统信 息处理功能需要的、不考虑存储物理介质和技术手 段的数据存储环节。
数据流：与所描述系统信息处理功能有关的各类信 息的载体.

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219204158677.png" alt="image-20211219204158677" style="zoom:80%;" />

仅仅一套数据流图并不能构成系统说明书，只有当图 中出现的每一个成分都给出详细定义之后，才能较 全面地描述一个系统
数据流图中所有名字的定义及描述就构成了一本字典， 它包括数据流、数据存储、外部项和处理过程的详细 条目
**数据流、数据存储等数据型条目构成数据字典**（data dictionary）
数据字典是数据流图的辅助资料，对数据流图起注解 作用。数据字典主要用于描述数据流和数据存储的逻 辑内容，以及外部项和处理过程的某些数据特性                                       

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219210741432.png" alt="image-20211219210741432" style="zoom:67%;" />

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219210810318.png" alt="image-20211219210810318" style="zoom:77%;" />

**利用DFD建模步骤**

:one: 建立顶级DFD

:two: 自顶向下，功能分解

> –  自顶向下、逐步求精对顶级数据流图进行精化， 生成下一级数据流图
> –  对用户的需求描述进行语法分析
> •   名词或名词短语构成潜在数据流、数据存储和外部 实体
> •    动词构成潜在的处理功能

:three: 利用数据字典进行数据补充描述

![image-20211219211310043](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219211310043.png)

## 面向对象设计与UML

![image-20211219211705654](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219211705654.png)

面向对象软件开发的核心思想就是**高内聚（封装）和低耦合（消息驱动）**，使用简洁的接口拼合简单的部件

对象间依靠相互发送消息或响应消息实现通信；可以说， **消息是驱动面向对象程序运转的源泉。**

消息的三个性质:

> (1) 同一个对象可以接收不同形式的多个消息，作出不同的响应;
> (2) 相同形式的消息可以传递给不同的对象，所作出的响应可以是不同的;
> (3) 接收对象对消息的响应并不是必须的，对象可以响应消息，也可以不响应。

### 类之间的主要关系

类之间主要存在的关系：依赖、关联、聚合、组合、实现 和泛化。

![image-20211219214042093](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219214042093.png)

![image-20211219214642390](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219214642390.png)

![image-20211219214924191](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219214924191.png)

### UML的三个模型

UML的三个模型：功能模型、静态模型、动态模型

MDA

![image-20211219220348542](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219220348542.png)

### 用例图

用例图包含三部分：**用例use case 、参与者actor和关系relationship**

用例图是被称为参与者的外部用户所能观察到的系统功能的模型图

用例图列出系统中的用例和系统外的参与者，并显示哪个参与者参与了哪个用例的执行 

用例图多用于静态建模阶段(主要是业务建模和需求建模)。

**关系：泛化、扩展、包含、关联**

![](https://gitee.com/yi-junquan/image_gitee/raw/master/images/学籍用例图.png)

#### 关联

表示参与者与用例之间的通信，任何一方都可发送或接受消息。

#### 泛化

泛化关系是两个用例或两个参与者之间的关系。当多个用例共同拥有一种类似的结构和行为的时候,可以将它们的共性抽象为父
用例,其他的用例作为子用例,用例间的这种关系被称为用例的泛化关系。A 是 B的泛化,意味着 A 描述的是一般的行为,而 B是这些行为的详细(Specific)版本,A被称为父用例(Parent Use Case)或基用例(Base Use Case),B被称为子用例(Child UseCase)。

在用例的泛化关系中，子用例是父用例的一种特殊形式，子用例继承（Inherit）了父用例所有的结构、行为和关系。在用例图中,泛化关系用实线加上空心的箭头来表示。子用例被连接在箭头的尾部,箭头指向父用例。以PPS项目为例,用例Create Wholesale Order和Create Retail Order 都包括一系列公共的行为,如系统提供空白订货单表、业务员输入客户信息、业务员选择产品销售方式、业务员填写需求数量、系统显示产品价格并且合计总价等，因此，可以将这些公共的行为泛化为用例 Create Order,

![image-20211219222920725](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219222920725.png)

参与者之间也存在着这种泛化关系。例如，如果建模了一个数据库管理员和一个备份管理员,然后发现他们的工作中有一部分是重叠的,那么,就可以创建一个称为系统管理员的参与者作为数据库管理员和备份管理员的泛化。

#### 扩展

扩展是两个用例之间的关系,它使得每个用例可以通过扩展用例向基用例中添加额外的行为来扩展基用例的功能。用例的扩展机制允许从一个基用例开始开发一个复杂的系统,并且能够在不改变基用例的前提下向基用例中扩展更多的行为。用例 A扩展了用例B,则A称为扩展用例(Extend Use Case)或子用例,B称为基用例,它表示扩展**用例A的事件流在一定的条件下按照相应的扩展点可插人基用例B**中，这就
需要在基用例中定义一至多个已命名的扩展点。选用扩展关系可以把一些可选的操作独立封装在另外的用例中,避免基用例过于复杂。
扩展关系用虚线加上开箭头来表示。扩展用例被连接在箭头的尾部,箭头指向基用例,在虚线处添加一个<< extend >>表示扩展关系。例如,在基用例 Compare Inventory中,如果库存量足够多,则可以启动零配件出库的功能,如果库存量不足则需要创建采购合同。所以Stock Out 和Create Purchase Contract是在用例Compare Inventory基础上的扩展,可将其建模为扩展关系,如图2-11所示。

![image-20211219223505490](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219223505490.png)

#### 包含

包含是两个用例之间的关系。当多个用例需要用到同一段行为时,可以把这段共同的行为单独抽象成为一个用例,然后让其他的用例来包含这一用例,从而避免在多个用例中重复描述同一段行为,也可以防止该段行为在多个用例中的描述出现不一致性。当需要修改这段公共的需求时,也只需要修改一个用例,避免同时修改多个用例而产生的不一致性和重复性工作。用例 A 包含 B,将 A 称为基用例,B 称为被包含用
例（Inclusion Use Case）。包含关系表示基用例会用到被包含用例,**被包含用例的事件流在基用例的某个点处插人到基用例的事件流中。**
**值得注意的是,对于包含关系而言,子用例中的事件流是一定插人到基用例中去的，并且插人点只有一个，而扩展关系可以根据一定的条件来决定是否将扩展用例的事件流插人到基用例事件流，并且插人点可以有多个。包含关系是无条件的，扩展关系是有条件的。**含关系用虚线加上箭头来表示。基用例被连接在箭头的尾部,箭头指向被包含用例,在虚线处添加一个<< include >>标签以表示包含关系,如图 所示。

![image-20211219223855295](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219223855295.png)

在 PPS 项目中，选择产品状态（Choose Product Condition）会在许多场合下发生，在创建销售订单和创建询价单中选择产品状态都是必不可少的活动,所以把选择产品状态作为一个被包含的用例插人到Create Order和Create Enquiry 用例中，如果需要改动选择产品状态用例,则不用对每一个用例都做相应修改,这样就提高了用例模型的可维护性。

#### 用例描述

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219225014902.png" alt="image-20211219225014902" style="zoom: 67%;" />

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219225313759.png" alt="image-20211219225313759" style="zoom:67%;" />

![image-20211219231342705](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219231342705.png)



### 





### 状态机图

一个对象有多个状态

仅依靠顺序图或通信图来建立对象的行为模型还不够,还需要全面地分析该对象所有可能的状态以及从一个状态过渡到另一个状态的条件。UML的状态图（StateDiagram)特别适合为那些行为由其状态决定的对象建模,它描述了一个对象可能处于的各种不同状态以及这些状态之间的转移。因此,UML的状态图是有效的基于对象状态的行为建模工具。

状态图由状态和迁移组成，表达方式为：`状态图=状态+迁移`

   状态(state)是指在对象的生命期中的某个条件或状况，在此期间对象将满足某些条件、执行某些活动或等待某些事件。所有对象都具有状态，状态是对象执行了一系列活动的结果，当某个事件发生后，对象的状态发生变化。

   状态图(statechart diagram):
   用来描述一个特定的对象所有可能的状态,以及由于各种事件的发生而引起的状态之间的转移和变化。
并不是所有的类都需要画状态图，有明确意义的状态，在不同状态下行为有所不同的类才需要画状态图。如下，
一个机器的状态图

[![image](https://images0.cnblogs.com/blog/707050/201501/171116551364800.png)](https://images0.cnblogs.com/blog/707050/201501/171116545427686.png)

 

再如，CD Player的状态图

[![image](https://images0.cnblogs.com/blog/707050/201501/171116561986459.png)](https://images0.cnblogs.com/blog/707050/201501/171116556514359.png)

**1.状态**
一个状态有以下几个部分：状态名(name)、进入／退出动作(entry／exit action)、内部转移(internal transttion)、子状态(substate)、延迟事件(dferred event)。
状态可以细分为不同的类型，例如初态、终态、中间状态、组合状态、历史状态等。一个状态图只能有一个初态，但终态可以有一个或多个，也可以没有终态。
中间状态包括两个区域：名字域和内部转移域，如图所示。其中内部转移域是可选的。

[![image](https://images0.cnblogs.com/blog/707050/201501/171116579337489.png)](https://images0.cnblogs.com/blog/707050/201501/171116568862602.png)

横线上面是名字域，下面是转换域（可选）。

> **entry/turnOn：**当转入该状态时，做开灯动作。
> **do/blinkFivetimes：**当处于该状态时，灯闪烁5次。do活动是只在状态内出现的活动，不能附加到转换上。
> **event poweroff/powerSupplySelf：**当电源关闭事件发生时，用自备电源。
> **exit/turnOff：**当转出该状态时，做关灯动作。
> **event selfTest/defer：**当selfTest事件发生时，对象将延迟响应，到别的状态中再处理，用defer这个特定动作表示延迟。

**2.状态图的要素**

> 
> **椭圆或圆角矩形：**表示对象的一种状态，椭圆内部填写状态名
> **箭头：**表示从箭头出发的状态可以转换到箭头指向的状态
> **事件：**引起状态转换的原因。事件名可在箭头线上方标出
> **条件：**事件名后加方括号，括号内写状态转换条件
> **实心圆：**初始状态
> **内部实心的同心圆：**最终状态

**3.状态的类型**

***①按状态过程分：***

[![image](https://images0.cnblogs.com/blog/707050/201501/171116595588019.png)](https://images0.cnblogs.com/blog/707050/201501/171116586203632.png)

***②含有子状态的状态被称为组合或嵌套状态***

[![image](https://images0.cnblogs.com/blog/707050/201501/171112381837268.png)](https://images0.cnblogs.com/blog/707050/201501/171112376203695.png)

组合状态可以使用“与”关系分解为并发子状态，或者通过“或”关系分解为互相排斥的顺序子状态。两种表示方法：
**顺序子状态**
如果一个组成状态的子状态对应的对象在其生命期内的任何时刻都只能处于一个子状态，即多个子状态之间是互斥的，不能同时存在，这种子状态称为顺序子状态。

[![image](https://images0.cnblogs.com/blog/707050/201501/171117011677076.png)](https://images0.cnblogs.com/blog/707050/201501/171117006361747.png)
**并发子状态**
有时组合状态有两个或者多个并发的子状态机，此时称组成状态的子状态为并发子状态。

[![image](https://images0.cnblogs.com/blog/707050/201501/171117024011021.png)](https://images0.cnblogs.com/blog/707050/201501/171117017614191.png)

③**历史状态**是伪状态, 其目的是记住从组合状态中退出时所处的子状态, 当再次进入组合状态时, 可以直接进入这个子状态, 而不是再从组合状态的初态开始。

> [![image](https://images0.cnblogs.com/blog/707050/201501/171112415424126.png)](https://images0.cnblogs.com/blog/707050/201501/171112411673312.png)浅(shallow)历史状态, 只记住最外层组合状态的历史。
>
> 
> [![image](https://images0.cnblogs.com/blog/707050/201501/171112424334500.png)](https://images0.cnblogs.com/blog/707050/201501/171112420422213.png)深(deep)历史状态, 可以记住任意深度的组合状态的历史。

CD Player，running状态被打断到power on状态，再转回到running状态时，希望直接进入历史状态

[![image](https://images0.cnblogs.com/blog/707050/201501/171112438702271.png)](https://images0.cnblogs.com/blog/707050/201501/171112430427384.png)

**4.转移（Transition）
**转移是两个状态间的一种关系，表示对象将在当前状态中执行动作，并在某个特定事件发生或某个特定的条件满足时进入后继状态。 每个转移只允许有一个事件触发，一个事件只允许有一个动作。

***①转移的五要素（注意格式）***

> **格式：事件（参数）[条件]/动作**
> ▪源状态
> ▪目标状态
> ▪触发事件
>    -如果箭头上不带任何事件名，表示是一个自动转换，当与源状态相关的活动完成时就会自动触发。
> ▪监护条件
> ▪动作

[![image](https://images0.cnblogs.com/blog/707050/201501/171117042613621.png)](https://images0.cnblogs.com/blog/707050/201501/171117032617449.png)

***②转换的类型***

内部转移：不导致状态改变的转移，不会执行entry和exit动作

[![image](https://images0.cnblogs.com/blog/707050/201501/171112463867472.png)](https://images0.cnblogs.com/blog/707050/201501/171112458395372.png)
外部转移
自转移

[![image](https://images0.cnblogs.com/blog/707050/201501/171112476044646.png)](https://images0.cnblogs.com/blog/707050/201501/171112469647815.png)

**5.事件（Event）**
事件是对一个时间和空间上占有一定位置的有意义的事情的规格说明。事件触发状态的转移。

> 
> **四类主要事件：**
> ▪信号事件
> ▪调用事件
> ▪变化事件
> ▪时间事件

***①信号signer事件
***对象之间通过发送信号和接收信号实现通信。信号是一种异步机制。在计算机中，鼠标和键盘的操作均属于此类事件。对于一个信号而言，对象一般都有相应的事件处理器，如onMouseClick（）等。

***②调用call事件***
表示一个操作的调度。一个对象请求调用另一个对象的操作
信号是一个异步事件，而调用事件一般是同步的。也就是说，当对象调用另一对象的操作时，控制就从发送者传送到接收者，该事件触发转换，完成操作后，接收者转换到一个新的状态，控制返还给发送者。

[![image](https://images0.cnblogs.com/blog/707050/201501/171112488392889.png)](https://images0.cnblogs.com/blog/707050/201501/171112482455774.png)

***③变化change事件
***用关键字When，后面跟布尔表达式
When(temperature>120)/alerm()
变化事件的意图是要频繁测试表达式，只要表达式由假变为真，事件就会发生。

[![image](https://images0.cnblogs.com/blog/707050/201501/171117058707380.png)](https://images0.cnblogs.com/blog/707050/201501/171117050897507.png)

注意: 变化事件与监护条件的区别

***④时间（time）事件***
时间事件是指在绝对时间或在某个时间间隔内发生的事情所引起的事件。
例如到达某一时间或经过了某一时间段。用关键字When 或After表示。

[![image](https://images0.cnblogs.com/blog/707050/201501/171112514017805.png)](https://images0.cnblogs.com/blog/707050/201501/171112509019719.png)

**6.状态图建模技术**

> **建模步骤：**
> ①找出适合用模型描述其行为的类。
> ②确定对象可能存在的状态。
> ③确定引起状态转换的事件。
> ④确定转换进行时对象执行的相应动作。
> ⑤对建模的结果进行相应的精化和细化。

### 活动图

**1. 活动图的概念**
    活动图(activity diagram)是UML的动态视图之一，用来描述事物或对象的活动变化流程。活动图可看作状态图的特殊形式。特殊性在于活动图中的一个活动结束后将立即进入下一个活动而不需要事件触发活动的转移。

   活动图用于描述系统的工作流程和并发行为。活动图被设计用于简化描述一个过程或操作的工作步骤。例如，可以用活动图对一个软件的开发过程建模；还可以对诸如求Fibnacci数列第n个数的数值之类的操作进行建模。

活动图示例：

[![image](https://images0.cnblogs.com/blog/707050/201501/171112525735263.png)](https://images0.cnblogs.com/blog/707050/201501/171112520428934.png)

**2.活动图的组成元素:**

> 
> ▪活动（Activity）
> ▪动作流（Action Flow）
> ▪分支（Branch）与合并（Merge）
> ▪分叉（Fork）和汇合（Join）
> ▪泳道（Swimlane）
> ▪对象流（Object Flow）

**3.活动**

活动（activity）表示的是某流程中的任务的执行，它可以表示某算法过程中语句的执行。活动在活动图中表现为一个由一系列动作组成的非原子的执行过程。

> 
> 动作状态（Action State）
> 活动状态（Activity State）

***①动作状态***

动作状态是指执行原子的、不可中断的动作，并在此动作完成后通过完成转换转向另一个状态的状态。
动作状态使用平滑的圆角矩形表示，动作状态所表示的动作写在圆角矩形内部。

[![image](https://images0.cnblogs.com/blog/707050/201501/171112536205450.png)](https://images0.cnblogs.com/blog/707050/201501/171112530586579.png)

***②活动状态***

活动状态是可分解的，不是原子的，其工作的完成需要一定的时间。
可把动作状态看作活动状态的特例。
活动状态的表示图标也是平滑的圆角矩形，并可以在图标中给出入口动作和出口动作等信息。

[![image](https://images0.cnblogs.com/blog/707050/201501/171112550426450.png)](https://images0.cnblogs.com/blog/707050/201501/171112542616578.png)

**4.动作流**

所有动作状态之间的转换流称之为动作流。
活动图的转换不需要特定事件的激发，一个动作状态执行完后自动转换到另外一个状态。
活动图的转换用带箭头的直线表示。
可用条件限制转换。

[![image](https://images0.cnblogs.com/blog/707050/201501/171112561513124.png)](https://images0.cnblogs.com/blog/707050/201501/171112556206794.png)

**5.分支与合并**

分支一般用于表示对象类所具有的条件行为。
条件行为用分支和合并表达。
一个分支有一个入转换和两个带条件的出转换，出转换的条件应当是互斥的。
一个合并有两个带条件的入转换和一个出转换，合并表示从对应的分支开始的条件行为的结束。

[![image](https://images0.cnblogs.com/blog/707050/201501/171112572614095.png)](https://images0.cnblogs.com/blog/707050/201501/171112566838453.png)

**6.分叉与汇合**

分叉用于将动作流分为两个或者多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。
分叉可以用来描述并发线程。
汇合代表两个或多个并发控制流同步发生，当所有的控制流都达到汇合点后，控制才能继续往下进行。

[![image](https://images0.cnblogs.com/blog/707050/201501/171112588233840.png)](https://images0.cnblogs.com/blog/707050/201501/171112579338168.png)

**7.泳道**

泳道将活动图中的活动化分为若干组，并把每一组指定给负责这组活动的业务组织，通常为对象。
泳道区分了负责活动的对象，明确地表示了哪些活动是由哪些对象进行的。
每个活动只能明确地属于一个泳道。
泳道用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道上方可以给出泳道的名字或对象（对象类）的名字，该对象（对象类）负责泳道内的全部活动。
泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。

[![image](https://images0.cnblogs.com/blog/707050/201501/171113004176126.png)](https://images0.cnblogs.com/blog/707050/201501/171112593705940.png)

**8.活动的分解**

一个活动可以分为若干个动作或子活动，这些动作和子活动本身可以组成一个活动图。
一个不含内嵌活动或动作的活动称之为简单活动；一个嵌套了若干活动或动作的活动称之
为组合活动，组合活动有自己的名字和相应的子活动图。

[![image](https://images0.cnblogs.com/blog/707050/201501/171113019013614.png)](https://images0.cnblogs.com/blog/707050/201501/171113011677755.png)

一个包含子活动的活动和嵌套了子状态的组合状态类似，概念上也相对统一。

[![image](https://images0.cnblogs.com/blog/707050/201501/171113031831572.png)](https://images0.cnblogs.com/blog/707050/201501/171113026363770.png)

**9.活动图的用途**

> ▪对系统工作流程建模
>  工作流：是一个良好定义的动作序列，执行时将产生一个可观察的值，或者产生一个个体或实体的对象。
> ▪对工程组织过程建模
> ▪对算法流程建模

***①对系统工作流的建模***

[![image](https://images0.cnblogs.com/blog/707050/201501/171113048237872.png)](https://images0.cnblogs.com/blog/707050/201501/171113039171729.png)
***②对工程组织过程建模***

[![image](https://images0.cnblogs.com/blog/707050/201501/171113066836175.png)](https://images0.cnblogs.com/blog/707050/201501/171113055739501.png)
***③对算法流程建模***

[![image](https://images0.cnblogs.com/blog/707050/201501/171113079799903.png)](https://images0.cnblogs.com/blog/707050/201501/171113074958588.png)

**10.活动图建模技术**

> **
> **①识别要对其工作流描述的类或对象。
> ②确定工作流的初始状态和终止状态，明确工作流的边界。
> ③对动作状态或活动状态建模。
> ④对动作流建模。
> ⑤对对象流建模。
> ⑥对建立的模型进行精化和细化

### 活动图与状态图的比较

**1.活动图与状态图的相同点**：
  都是对系统的动态行为建模。

**2.活动图与状态图的区别：
\*①描述对象不同\***

> 
>     **状态图：**描述对象状态及状态之间的转移；
>     **活动图：**描述从活动到活动的控制流。


***②使用场合不同***

> 
>     **状态图：**描述对象在其生命期中的行为状态变化；
>     **活动图：**描述过程的流程变化。

### 顺序图

![image-20211219231940383](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219231940383.png)

顺序图的概念: 顺序图是按时间顺序显示对象交互的图。它显示了参与交互的对象和所交换信息的先后顺序，用来表示用例中的行为，并将这些行为建模成信息交换。

顺序图是一![image-20211219231940383](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211219231940383.png)种交互图，强调消息的时间顺序，亦称时序图

 

顺序图主要包括四个元素：对象、生命线、激活和消息。

在UML中，顺序图将交互关系表示为一张二维图。

其中纵向是代表时间维度，时间向下延伸，按时间依次列出各个对象所发出和接收的消息。水平方向是代表对象的维度，排列着参与交互的各个独立的对象。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205022643-442000168.png)

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205028411-980536992.png)

顺序图的三种主要作用：

1）细化用例的表达。本章前面我们已经提到，使用顺序图的一大用途，就是讲用例所描述的需求与功能转化为更加正式、层次更加分明的细化表达。

2）有效地描述类职责的分配方式。我们可以根据顺序图中各对象之间的交互关系和发送的消息来进一步明确对象所属类的职责。

3）丰富系统的使用语境的逻辑表达。系统的使用语境即为系统可能的使用方式和使用环境。

 

顺序图的组成元素：对象、生命线、激活、消息。

 

对象

　　顺序图中的对象与对象图中的概念一样，都是类的实例。顺序图中的对象可以是系统的参与者或者任何有效的系统对象。

　　对象的创建由头符号来表示，即在对象创建点的生命线顶部使用显示对象名和类名的矩形框来标记。

　　在位置上，一个被放置于顺序图顶端的对象，意味着在这个交互的开始之前，我们已经拥有这样一个对象了。如果一个对象出现在其它位置上（不在顶端），则说明这个对象是在交互执行到某些步骤的时候被创建出来的。被创建出来的对象可以在接下来的时间里被其它对象的消息所激活，也可以以同样的方式被销毁。

 

生命线

　　生命线代表了一次交互中的一个参与对象在一段时间内存在。具体地说，在生命线所代表的时间内，对象一直是可以被访问的——可以随时发送消息给它。

　　在顺序图中，生命线位于每个对象的底部中心位置，显示为一条垂直的虚线，与时间轴平行，带有一个显示对象的头符号。

　　对于在交互过程中被创建的对象，其生命线从接收到新建对象的消息时开始。对于在交互过程中被销毁的对象，其生命线在接收到销毁对象的消息时或在自身最后的返回消息之后结束，同时用一个“X”标记表明生命线的结束。

 

激活

　　激活，又称为控制焦点，表示一个对象执行一个动作所经历的时间段，既可以是直接执行，也可以是安排下级过程执行。同时，激活也可以表示对应对象在这段时间内不是空闲的，它正在完成某个任务，或正被占用。

　　激活在UML中用一个细长的矩形表示，显示在生命线上，如图8-5所示。矩形的顶部表示对象所执行动作的开始，底部表示动作的结束。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205112404-1233439764.png)

 

消息

　　除了以上这些消息类型以外，Rose还扩充了两种消息类型，分别是阻止消息与超时消息。

　　　　阻止消息：当消息的发送者传递消息给接收者，如果接收者无法立即接收，则发送者放弃该消息。

　　　　超时消息：若发送消息后接收者无法在指定时间内接收，则发送者放弃该消息。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205133567-1671302313.png)

 

顺序图中的结构化控制

在UML 2中，顺序图提供了“片段” 机制，可以通过顺序图来表达更加复杂的动作序列。

可选片段：关键字为opt，表示一种单条件分支。

条件片段：关键字为alt，表示一种多条件分支。

并行片段：关键字为par，表示片段内有多个并行子片段的片段。

循环片段：关键字为loop，表示一个循环。

交互片段：关键字为ref，表示对一段交互的引用。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205157586-723741847.png)

 

 

 

顺序图建模技术

按时间顺序对控制流建模：

　　设置交互的语境。交互语境即交互所在的环境，包括交互属于那个系统、子系统，包含哪些类和对象，对应于哪个用例或协作的脚本等。

　　设置交互的场景，即识别对象在交互中扮演的角色，根据对象的重要性排列对象的顺序。

　　为对象设置生命线。

　　按时间顺序排列消息。

　　设置激活期。

　　附加时间和空间约束。

　　设置前置与后置条件。

 

 

补充

顺序图的变体——时间图

时间图是UML 2中新增加的图，相当于另一种显示顺序图的方法。

时间图与顺序图的主要不同之处有：

1）时间轴与对象轴交换了位置。在时间图中，纵向表示不同对象，横向表示时间的延伸。

2）不同对象的生命线在独立的矩形框中显示，矩形框纵向堆砌成整个图。

3）对象可以有不同的状态。每个对象的状态在其生命线的最左侧纵向排列，生命线通过上下起伏来表示对象当前所处的状态。

4）可以显示一个时间标尺。时间标尺上有时间刻度，用来表示时间间隔。

5）不同对象生命线上的时间是同步的。

 

 

建立顺序图的步骤：

1.确定需要建模的工作流

2.从左到右布置对象

3.添加消息和条件以便创建工作流

 

例子：系统用户注册模块

 ![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205247327-1282770799.png)

 

 

案例（1）就餐

需求描述如下：

   客人到餐厅就餐，服务员提供菜单，客人点菜后把菜单交给服务员。服务员向客人确定菜单后，将菜单提交给大堂经理。大堂经理把菜单提交给大厨，大厨完成菜品后传递给大堂经理，大堂经理安排服务员传菜。有的客人可能需要酒水，有的客人不需要酒水。客人结束用餐后，服务员提供账单，客人结账。

 

确认对象

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205306091-374901915.png)

 

确定出现顺序

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205313203-1999549378.png)

 

确定消息

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205321828-1087174687.png)

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205326878-326453030.png)

 

 

 

案例（2）ATM机取款

需求描述如下：

　　用户通过ATM机，插入银行卡。系统提示输入密码，用户输入密码。系统检查密码是否正确，密码正确用户选择取款。系统提示输入取款金额。用户输入金额，系统判断其合法性。在获取用户输入金额后，系统开始事物处理，减少账户金额，输出相应现金。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205342017-1329089546.png)

 

 

 

案例（3）成绩查询

需求描述如下：

　　老师通过学号在系统查询成绩，有存在、不存在两种情况。存在显示成绩，不存在显示查无此人。

![img](https://img2018.cnblogs.com/blog/1130413/201902/1130413-20190208205401085-379588736.png)

### 构件图

描述系统构件间的关系，关注**软件的配置信息。**

构件图用于**静态建模**，是表示构件类型的组织以及各种构件之间 依赖关系的图。
构件图通过对构件间依赖关系的描述来估计对系统构件的修改给 系统可能带来的影响。

### 部署图

描述系统软硬件的配置信息

### 类图

**类的UML画法**

Java是一门面向对象语言，那最基础的就类了。**类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称**。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样子的功能，要承担什么样子的义务。一个类可以有多种职责，但是设计得好的类一般只有一种职责。

假如我现在定义了这么一个类：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Person {
    private String name = "Jack";

    public String getName()     {
        return name;
    }

    public void setName(String name)     {
        this.name = name;
    }
    
    protected void playBasketball()     {
        pass();
    }
    
    private void pass()     {
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

那么此类对应的UML为：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160526213237522-1915677228.png)

看到该图分为三层：最顶层的为类名，中间层的为属性，最底层的为方法。

属性的表示方式为：【可见性】【属性名称】：【类型】={缺省值，可选}

方法的表示方式为：【可见性】【方法名称】（【参数列表】）：【类型】 

可见性都是一样的，**"-"表示private、"+"表示public、"#"表示protected**。

 

**继承关系**

继承也叫作泛化（Generalization），用于描述父子类之间的关系，父类又称为基类或者超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的**实线**来表示。

假如现在我又定义了一个Student和一个Teacher：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Student extends Person {
    private String studentNo;
    
    public void study()     {
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Teacher extends Person {
    private String teacherNo;
    
    public void teach()     {
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

那么，用UML表示这种关系应当是：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160526215931522-1646286150.png)

 

**抽象继承关系**

上面的继承是普通的继承，在Java中，除了普通的继承之外，众所周知的还有一种抽象的继承关系，因此就再讲讲抽象继承关系，作为上面的继承的补充。

比方说我想实现一个链表（Link），插入（insert）与删除（remove）动作我想让子类去实现，链表本身只实现统计链表中元素个数的动作（count），然后有一个子类单向链表（OneWayLink）去实现父类没有实现的动作，Java代码为：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public abstract class Link
{
    public abstract void insert();
    public abstract void remove();
    
    public int count()
    {
        return 0;
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class OneWayLink extends Link
{
    public void insert()
    {
        
    }

    public void remove()
    {
        
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

其UML的画法为：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160527114702178-249327726.png)

在UML中，抽象类无论类名还是抽象方法名，都以**斜体**的方式表示，因为这也是一种继承关系，所以子类与父类通过带空心三角形的实线来联系。

 

**实现关系**

很多面向对象的语言中都引入了接口的概念，如Java、C#等，在接口中通常没有属性，而且所有的操作都是抽象的，只有操作的声明没有操作的实现。UML中用与类类似的方法表示接口，假设我有一个Animal：

```
public interface Animal {
    public void move();
    public void eat();
}
```

那么它的UML应当表示为：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160526221832147-1880550460.png)

很简单，注意在方法上应当有<<interface>>表示这是一个接口。接口一般没有属性，所以这里中间层没有，有属性要注意也都是常量。

接下来，有一个Dog和一个Cat实现了Animal：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Dog implements Animal {
    public void move()     {
        
    }

    public void eat()     {
        
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Cat implements Animal {
    public void move()     {
        
    }

    public void eat()     {
        
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

此时应当使用带空心三角形的**虚线**来表示，UML应该是这样的：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160526222227334-1295693913.png)

两个抽象方法，Dog和Cat的实现将不一样，当然，在Dog和Cat之中，也可以增加Dog和Cat自己的变量和方法。

**关联关系**

关联（Assocition）关系是类与类之间最常见的一种关系，它是一种结构化的关系，表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。在UML类图中，用实线连接有关联关系的对象所对应的类，**在Java中通常将一个类的对象作为另一个类的成员变量**。关联关系分单向关联、双向关联、自关联，逐一看一下。

**1、单向关联关系**

单向关联指的是关联只有一个方向，比如顾客（Customer）拥有地址（Address），其Java实现为：

```
public class Address
{

}
public class Customer
{
    private Address address;
}
```

UML的画法为：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160526224208881-211185502.png)

**2、双向关联关系**

默认情况下的关联都是双向的，比如顾客（Customer）购买商品（Product），反之，卖出去的商品总是与某个顾客与之相关联，这就是双向关联。Java类的写法为：

```
public class Product
{
    private Customer customer;
}
public class Customer
{
    private Product[] product;
}
```

对应的UML类图应当是：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160526224957319-736110479.png)

**3、自关联关系**

自关联，指的就是对象中的属性为对象本身，这在链表中非常常见，单向链表Node中会维护一个它的前驱Node，双向链表Node中会维护一个它的前驱Node和一个它的后继Node。就以单向链表为例，它的Java写法为：

```
public class Node
{
    private Node nextNode;
}
```

对应的UML类图应当是：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160526225654053-2061511983.png)

 

**聚合关系**

聚合（Aggregation）关系表示整体与部分的关系。在聚合关系中，**成员对象是整体的一部分，但是成员对象可以脱离整体对象独立存在**。在UML中，聚合关系用带空心菱形的直线表示，如汽车（Car）与引擎（Engine）、轮胎（Wheel）、车灯（Light），Java表示为：

```
public class Engine
{

}
public class Wheel
{

}
public class Light
{

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Car
{
    private Engine engine;
    private Light light;
    private Wheel wheel;
    
    public Car(Engine engine, Light light, Wheel wheel)
    {
        super();
        this.engine = engine;
        this.light = light;
        this.wheel = wheel;
    }
    
    public void drive()
    {
        
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

对应的UML类图为：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160527101106975-1990587882.png)

代码实现聚合关系，**成员对象通常以构造方法、Setter方法的方式注入到整体对象之中**。

 

**组合关系**

组合（Composition）关系也表示的是一种整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也不存在，整体对象和成员对象之间具有同生共死的关系。在UML中组合关系用带实心菱形的直线表示。

比如人的头（Head）和嘴巴（Mouth）、鼻子（Nose），嘴巴和鼻子是头的组成部分之一，一旦头没了，嘴巴也没了，因此头和嘴巴、鼻子是组合关系，Java表示为：

```
public class Mouth
{

}
public class Nose
{

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Head
{
    private Mouth mouth;
    private Nose nose;
    
    public Head()
    {
        mouth = new Mouth();
        nose = new Nose();
    }
    
    public void shake()
    {
        
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

其UML的表示方法为：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160527102348788-2073210568.png)

代码实现组合关系，通常在**整体类的构造方法中直接实例化成员类**，这是因为组合关系的整体和部分是共生关系，如果通过外部注入，那么即使整体不存在，那么部分还是存在的，这就相当于变成了一种聚合关系了。

 

**依赖关系**

依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系，大多数情况下依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。

比如，驾驶员（Driver）开车，Driver类的drive()方法将车（Car）的对象作为一个参数传递，以便在drive()方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此也可以说Driver依赖Car，Java代码为：

```
public interface Car
{
    public void move();
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public class Driver
{
    public void drive(Car car)
    {
        car.move();
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

其UML的画法为：

![img](https://images2015.cnblogs.com/blog/801753/201605/801753-20160527111442944-1797116461.png)

依赖关系通常通过三种方式来实现：

> 1. 将一个类的对象作为另一个类中方法的参数
> 2. 在一个类的方法中将另一个类的对象作为其对象的局部变量
> 3. 在一个类的方法中调用另一个类的静态方法

 

**关联关系、聚合关系、组合关系之间的区别**

从上文可以看出，关联关系、聚合关系和组合关系三者之间比较相似，本文的最后就来总结一下这三者之间的区别。

关联和聚合的区别主要在于语义上：**关联的两个对象之间一般是平等的，聚合则一般是不平等的**。

聚合和组合的区别则在语义和实现上都有差别：**组合的两个对象之间生命周期有很大的关联，被组合的对象在组合对象创建的同时或者创建之后创建，在组合对象销毁之前销毁，一般来说被组合对象不能脱离组合对象独立存在，而且也只能属于一个组合对象；聚合则不一样，被聚合的对象可以属于多个聚合对象**。

再举例子来说：

- 你和你的朋友属于关联关系，因为你和你的朋友之间的关系是平等的，关联关系只是表示一下两个对象之间的一种简单的联系而已，就像我有一个朋友
- 你和你借的书属于聚合关系，第一是因为书可以独立存在，第二是因为书不仅仅属于你，也可以属于别人，只是暂时你拥有
- 你和你的心脏属于组合关系，因为你的心脏只是属于你的，不能脱离与你而存在

不过，实际应用中，我个人感觉三种关系其实没有区分得这么清楚，有些架构师甚至会说"组合和聚合没什么区别"，所以，有时候不需要把细节扣得这么细，合理利用对象之间的关系给出设计方案即可。

### 面向对象设计原则

**易用性原则**：易维护性、可扩展性、可重用性

设计原则如下

#### 单一职责原则

单一职责原则有什么好处：

> 1、类的复杂度降低，实现什么职责都有清晰明确的定义；
> 2、可读性提高；复杂度降低，那当然可读性提高了；
> 3、可维护性提高，可读性提高，那就更容易维护了；
> 4、变更引起的风险降低；也就是说提高了扩展性和可维护性。

#### 开放封闭原则

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211220104231739.png" alt="image-20211220104231739" style="zoom:67%;" />

考虑设计中什么可能会发生变化，将其封装起来，考虑允许什么发生而不让 这一变化导致重新设计。
•   声明的变量的类型、函数的参数类型、函数的返回类型等要尽量使用抽象类 和接口。

#### 接口隔离原则

设计时采用多个与特定客户类有关的接口比采用一个通用的接口好

![image-20211220104616552](https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20211220104616552.png)

#### 依赖倒置原则

高层模块不应该依赖于低层模块,二者都应该依赖于抽象。
抽象不应该依赖于细节,细节应该依赖于抽象。

抽象反映高层策略
• 仔细分析需求，先找出那些业务规则，然后把它们抽象出来形成你的 接口。
• 层次化你的设计，常见的方式就是划分出显示层，业务层，持久层， 再在每层做抽象。
• 在实现的时候始终遵循 前面提到的原则：只依 赖于接口。
• 谁也无法在开始就做到 最好，因此要不断迭代 精化设计。

#### 里氏替换原则

子类可以扩展父类的 功能，但不能改变父类原有的功能。

在软件中将一个基类对象替换成它的子类 对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软 件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展 自己的功能。当功能扩展时，子类尽量不要重写父类的方法，而是另写一个方法，所以 对上面的代码加以更改，使其符合里氏替换原则，

**里氏替换原则是实现开闭原则的重要方式之一**，由于使用 基类对象的地方都可以使用子类对象，因此在程序中尽量使 用基类类型来对对象进行定义，而在运行时再确定其子类类 型，用子类对象来替换父类对象。

**注意**

1 子类的所有方法必须在父类中声明，或子 类必须实现父类中声明的所有方法。根据里氏 替换原则，为了保证系统的扩展性，在程序中 通常使用父类来进行定义，如果一个方法只存 在子类中，在父类中不提供相应的声明，则无
法在以父类定义的对象中使用该方法。

2、我们在运用里氏替换原则时，尽量把父类设计为抽象类 或者接口，让子类继承父类或实现父接口，并实现在父类中 声明的方法，运行时，子类实例替换父类实例，我们可以很 方便地扩展系统的功能，同时无须修改原有子类的代码，增 加新的功能可以通过增加一个新的子类来实现。里氏替换原 则是开闭原则的具体实现手段之一。

3、在系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法，可以有效降低代码出错的可能性。

#### 合成/聚合复用原则

该原则的简述：要尽量使用合成/聚合，尽量不要使用继承。
• 合成/聚合复用原则，也称合成复用原则：就是在一个新的对象里面使用一 些已有的老对象，使之成为新对象的一部分；新的对象通过向这些老对象 的委派，达到复用已有功能的目的。
•   合成：
• 合成关系中，新对象在整体角度，对其组成部分拥有完全的支配权，包括 他们的创建和湮灭。即组合而成的新对象对组成部分的内存分配、内存释 放有绝对的责任。
• 一个合成的多重性不能超过1，即，一个合成关系中的成分对象不能与另外 一个合成关系共享。一个合成关系湮灭了，则所有的成分对象在同一时间 内都会被湮灭。

#### 迪米特原则

迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），一个对象应该对其他对象有最少的了解。

### 基于模式的事件处理机制

四类主要事件：信号事件、调用事件、变化事件、时间事件

SOA：面向服务架构



