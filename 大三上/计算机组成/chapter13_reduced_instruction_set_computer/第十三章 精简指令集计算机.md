[TOC]

# 第十三章 精简指令集计算机

## KEY POINTS

> **1、产生背景，系列机的概念**
>
> **2、主要的三个特征**
>
> **3、大寄存器组中，关于局部变量如何处理，全局变量如何处理，跟cache相比的优缺点**
>
> **4、编译器如何优化寄存器**
>
> **5、RISC和CISC的区别与优缺点**
>
> **6、RISC的流水线优化技术是什么：延迟槽技术**



## 13.1 指令执行的特征

指令执行关注的方面：执行的操作、所用的操作数、执行顺序

### 操作operation

:one: 赋值语句在程序中出现的频率最高

> 数据传送非常频繁

:two: 条件语句出现的频率也较高

> 指令的顺序控制非常重要

:three: 过程调用/返回的操作耗时最多

> 但过程调用的深度一般不会很深

### 操作数operand

主要使用的是简单的标量变量，且其中很大比例又是局部标量变量

优化的主要方向应是对局部标量变量**local variables**进行快速的存储和访问

### 过程调用|Procedure Calls

最耗时

> 取决于过程调用中使用参数及变量的个数
>
> 取决于嵌套的深度

每个过程调用所涉及数据传递的量并不大

绝大多数都是对局部变量的访问

大多数过程嵌套的深度不会很深

操作数的访问是符合局部性原理的

### 推论

让机器指令集更接近HLL效果并不好，通过优化最常用和最耗时的操作才能更好的支持HLL计算机高级语言。

:one: 使用大量寄存器

> 以避免对局部变量的访问需要访存

:two: 更为小心的设计指令流水线

> 专门处理转移

:three: 指令集设计应尽量简化或者说是精简

所以使用RISC有其必要性

## 13.2 大寄存器组的使用large register file

**寄存器特点**

> 比主存和cache还快
>
> 更短的地址
>
> 靠近CPU

寄存器数量有限，应把最经常访问的数据放入寄存器，以尽量减小访存操作，提高指令执行速度

### 计算机中寄存器的分配

#### 软件解决办法

依靠编译器分配寄存器

将寄存器分配给那些在给定时间期内使用最多的变量

要求使用复杂的程序分析算法

#### 硬件解决办法

配置更多的寄存器

使得更多的变量保存在寄存器中

### 寄存器窗口

使用一大组寄存器应该能减少对存储器访问的需求，因此设计的任务就是很好地组织寄存器来实现这个目标

#### 寄存器中的局部变量

将局部标量变量存储在寄存器中，以减小内存访问；每次过程（函数）调用都会改变 “局部变量”具体所指；原有过程的局部变量必须被送到存储器，以腾出寄存器空间供现有正在执行的过程的局部变量来使用

每次过程调用时

> 父过程的局部变量一般会压入栈
>
> 父过程给子过程的参数一般通过栈传递
>
> 子过程给父过程的结果一般通过栈返回

#### 寄存器窗口的使用

解决的方法是基两个结论。

> 第一，一个典型的过程只使用少数传送参数和局部变量。第二，过程调用的深度仅限定在一个相对窄的范围内。

为利用这些性质，使用多个小的寄存器组，每个小组指派给一个不同的过程。过程调用时自动地切换来使用**不同的但大小固定**的寄存器窗口，而不再在存储器保存寄存器内容。相邻过程的窗口是（部分）重叠的，以允许参数传递

![image-20211227085713193](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211227085713193.png)

每次只有一个寄存器窗口对用户可见

过程返回时自动切换回父过程使用的那组寄存器

**寄存器窗口的组成**

> 参数寄存器域
>
> 局部寄存器域
>
> 临时寄存器域
>
> > 一个窗口中的临时寄存器与下一窗口中的临时参数寄存器重叠

#### 环形缓冲组织

进行调用时，将移动当前窗口指针以指示当前活动过程的寄存器窗口

如果所有窗口都在使用中，则会生成一个中断，并将**最早的窗口（嵌套中最远的那个窗口）保存到内存中**

保存窗口指针指示最近保存在存储器的窗口

N个窗口的寄存器组仅能用于N-1个过程的直接调用

•Berkeley RISC，通常采用8个窗口，每个窗口16个寄存器

![image-20211227090013987](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211227090013987.png)

### 全局变量

一种的方法是让编译器为声明的全局变量指派存储器的地址

> 如果需要频繁访问的全局变量，效率较低

另一种的方法是给全**局变量单独分配一组寄存器**，专门放全局变量，供所有过程使用

独立于环形寄存器窗口，但和窗口寄存器统一编址

当全局变量的数目超过此寄存器组内寄存器的总数时，仍由编译器来决定哪些全局变量放在寄存器，哪些放回存储器

### 大寄存器组与cache的比较

:one: 基于窗口的寄存器更快，但缓存可以更有效地利用空间->能对动态变化的情况作出反应

:two: 缓存可能会遭受另一种效率低下的问题:数据被读入块但是其中一些不会被使用

:three: 在寄存器组中，使用内存相对频繁，组关联cache会受到覆盖使用的变量的影响

:four: 寄存器组的地址较短，比缓存快

通常，寄存器文件优于变量

## 13.3 基于编译器的寄存器优化

假定目标RISC机器上只有少量寄存器可用（如16~32个），这时优化寄存器的使用就是编译器的责任了。

高级语言编写的程序没有对寄存器的显示引用，程序中的量是用符号表示的。

**编译器的目标**：**尽可能在寄存器而不是在主存中为多数计算机保持操作数，并且减少装在和保存操作。**

<font color="\#145b7d">**如何优化**</font>

> 使用时间上不重叠的符号寄存器可共享同一物理寄存器
>
> 如果某一时段物理寄存器用尽，则某些变量仍需放回到存储器
>
> 编译器还需要对寄存器变量进行分析，来决定哪些变量放回存储器，使得程序能尽量减少访存次数

优化任务的本质——判定在程序的任何给定时间点，什么样的量应指派给寄存器中——**图着色法**

### 图着色法🎨

**图着色**：对于由结点和边组成的给定图，为节点指定颜色，并且使相邻节点不同色，而且要使颜色数最少。

<font color="red">**对于编译问题**</font>：图的节点就是符号寄存器，若两个符号寄存器同时“生存”在同一程序段，则相应的两个节点同一条边连接起来表示相关。尝试用n中颜色给图上色，n是指真实寄存器的数目。**如果这个问题无法成功，那么这些不能上色的节点必须放入存储器**中，当需要时必须使用装载和保存操作开辟寄存器空间。

<img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211119103322765.png" alt="image-20211119103322765" style="zoom:80%;" />

## 13.4 精简指令集架构

### 为什么选择CISC

使用CISC的理由：简化编译器、可生成更小更快的程序

### RISC特征

:one:  每个机器周期一条机器指令

:two: 大多数操作应该是寄存器到寄存器的

:three: 简单的寻址方式

:four: 简单的指令格式

:five: 更多的编译时间

### RISC vs CISC

**什么是RISC:question:**

> Reduced Instruction Set Computers，即精简指令集计算机
>
> <font color="red">**主要特征有**</font>
>
> > 通过大量的通用寄存器和（或）使用编译器技术来优化寄存器的使用
> >
> > 一个有限且简单的指令集
> >
> > 强调指令流水的优化

**什么是CISC**

> 复杂指令集计算机
>
> > 提供更大的指令集
> >
> > 提供更多的寻址方式
> >
> > 直接用硬件去实现的各种高级语言（HLL）句

**二者比较**

> RISC比CISC更能提高计算机的运算速度
>
> RISC比CISC更便于设计，可降低成本，提高可靠性
>
> RISC更有效支持HLL
>
> RISC在实现特殊功能时，效率比较低，可以通过流水线优化改进，CISC处理特定功能时效率比较高

其实很难比较，大多数商用机都是混合架构

## 13.5 RISC 流水线

大多数指令是寄存器到寄存器的，指令周期有两个阶段：

> I：指令获取
>
> E：指令执行

对于装在装载和保存操作，需要三个阶段

> I：取指令
>
> E：执行
>
> D：存储

![image-20211119105438478](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211119105438478.png)

NOOP：编译器加的，防止数据冲突或不相关的指令执行

### 流水线优化

#### 延迟转移

转移指令只有在执行后才能产生具体的影响

可以在转移指令取指之后执行结果出来之前，安排一条或几条不相关的但结果肯定有用的指令进入流水线执行，代替简单的NOOP空操作 --- 乱序执行

将在转移指令后，插入的用来减小转移损失的这些指令称为**延迟槽delay slot**

![](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20211119112906692.png)

#### 循环展开

循环展开：把一个循环的循环体复制若干次，其次数被称为展开因子（u），从而以步长u来执行循环，而不是1

提高性能的方式

> 降低循环开销
>
> 通过提高流水线性能提高并行性
>
> 提高寄存器、数据高速缓存或TLB的局部性

