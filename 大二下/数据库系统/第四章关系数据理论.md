

# [XJTUSE DATABASE]——第四章 关系数据理论

![image-20230503181045312](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20230503181045312.png)

## 一、关系模式设计中的问题

> 关系模式设计得好与坏，直接影响到数据冗余度、数据一致性等问题。
>
> 要设计好的数据库模式，必须有一定的理论为基础。这就是关系规范化理论。
>
> 关系规范化的过程是以达到高级别范式的关系去取代原有关系的过程。
>
> 随着规范程度的提高，冗余与操作异常可能性减少。

:star: **R<U,F>为一个关系模式：当且仅当U上的一个关系r满足F时，r称为该关系模式的一个关系**

> R：关系名R是一个符号化的元组语义
>
> U：一组属性
>
> F：属性U上的一组函数依赖

## 二、数据依赖

**数据依赖**

> 通过关系中**属性间值的相等与否**体现出的数据间的相互依存和制约关系；
>
> 是对现实世界中事物间相互联系的抽象,是数据的内在性质,是语义的体现。

**数据依赖的类型**

> 函数依赖（Functional Dependency，简记为**FD**）
>
> 多值依赖（Multivalued Dependency，简记为**MVD**）
>
> 连接依赖（Jion Dependency，简记为**JD**）

### 函数依赖

:one: **函数依赖定义**：设R为关系模式，r为R上的任意一个关系实例，X，Y是R的两个属性子集，若对于r上的任意两个元组t1，t2，都有：如果 t1[X]＝t2[X]，则必有t1[Y]=t2[Y]，则称在R上X函数决定Y或者Y函数依赖于X，记为X→Y，称X为决定子或左部，称Y为被决定子或右部。

> 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的**所有关系实例均要满足的约束条件。**
>
> 函数依赖是语义范畴的概念，只能根据数据的语义来确定函数依赖是否成立。
>
> :star: 例：对于学生关系
>
> > 学生(学号，姓名，性别，出生日期，班级，宿舍，专业)
> >
> > 班级→性别 是否成立？
> >
> > 如果规定“男女生分班”，则成立，否则，不成立。



:two: **定义4.2**：在关系模式R(U)中，对于U的子集X和Y：

​						如果X→Y，且Y $\subseteq$ X，则称X→Y是**平凡的函数依赖**

​						若X→Y，且Y $\not\subseteq$X,  则称X→Y是**非平凡的函数依赖**

> 对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡函数依赖。
>
> 在关系SC(Sno, Cno, Grade)中，
>
> 非平凡函数依赖： (Sno, Cno) → Grade
>
> 平凡函数依赖：  (Sno, Cno) → Sno 
> 							 (Sno, Cno) → Cno



:three: **定义4.3**：在关系模式R(U)中，如果X→Y，并且对于X的任何一个真子集X’，都有  $X’ \not\to Y$, 则称Y<mark>完全函数依赖</mark>于X，记作$X   \overset{F}\to  Y$。

 若X→Y，但Y不完全函数依赖于X，则称Y<mark>部分函数依赖</mark>于X，记作$X   \overset{p}\to  Y$。

完全函数依赖中的左部不包含冗余属性，即只要将决定子中的任何一个属性去掉，这个函数依赖就不再成立了

> :star: 例：在关系SC(Sno, Cno, Grade)中，
>
> 由于：Sno $\not \to$Grade，Cno$\not \to$ Grade， 
>
> 因此：(Sno, Cno)  $\overset{F} \to$   Grade



:four: **定义4.4**：在关系模式R(U)中，如果X→Y，Y→Z，且Y $\not\subseteq$X，Y$\not→$X，则称Z<mark>传递函数依赖</mark>于X。否则称Z<mark>直接函数依赖</mark>于X

> 如果Y→X， 即X←→Y，则Z直接依赖于X。
>
> 例: 在关系Std(Sno, Sdept, Mname)中，有：
>
> 	       Sno → Sdept，Sdept → Mname
> 		
> 			因此，Mname传递函数依赖于Sno



:five: **定义4.5：**设F是在关系模式R上的函数依赖的集合，X→Y是一个函数依赖，如果对于R的每个满足F的关系r也满足X→Y，那么称**F逻辑蕴涵X→Y**，记为F ⊨ X→Y

例如：{X→Y，Y→Z} ⊨ X→Z



:six: 定义4.6：由函数依赖集合F所逻辑蕴涵的全部函数依赖所构成的集合称为F的闭包，记作F+，即$ F^+＝\{ X→Y|F ⊨X→Y\}$

据定义4.6易知，函数依赖集的闭包F+具有以下特点：

> (1)$F \subseteq F^+$，这是因为根据闭包的定义F中的每个函数依赖必定也在中$F^+$；
>
> (2) $(F^+)^+＝F^+$，该性质说明闭包运算是幂等的，即F经过任意多次的闭包运算后其结果仍然等于$F^+$
>
> (3)如果$F＝F^+$，则称F是**完备的**

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220202174308602.png" alt="image-20220202174308602" style="zoom:50%;float:left" />



**函数依赖的推理规则**

设U是关系模式R的属性集，F是R上的函数依赖集，则有：

> A1**（自反律）**：如果$Y\subseteq X \subseteq U $ ，则X→Y成立；
>
> A2**（增广律）**：如果X→Y成立，且 $Z\subseteq U$ ，则XZ→YZ成立
>
> A3**（传递律）**：如果X→Y，Y→Z成立，则X→Z成立

人们又把自反律(A1),传递律(A2)和增广律(A3)称为**Armstrong公理**

​      由A1～A3易推出下面的三条推理规则也是正确的：

> **合并规则：**若X→Y，X→Z成立，则X→YZ成立；
>
> **伪传递规则：**若X→Y，WY→Z成立，则WX→Z成立；
>
> **分解规则：**若X→Y，且  ，则有X→Z；



:seven: **定义4.7**：给定关系模式R<U,F>，如果能由F根据Armstrong公理推导出X→Y，则称X→Y是F的**逻辑导出**，记为F=>X→Y



:eight: **定义4.8**：**属性集X关于R(U，F)上的函数依赖集合F的闭包**$X_F^+$定义为$X_F^+＝\{A|A∈U，F=> X→A\}$根据A1（自反律）可知对于任一属性集X一定有$X\subseteq X_F^+$，此外,求$X_F^+$ 的计算量应该远远小于求$ F^+$的计算量，因为$X_F^+$中的属性是可数的，最多就是属性全集U而已

引理4-2：X→Y可由Armstrong公理推出的**充分必要条件**是 $Y\subseteq X_F^+$

<mark>**算法4.1**</mark>：求属性集X(X U)关于U上的函数依赖集F的闭包

> 输入：X，F 
>
> 输出： $ X_F^+$
>
> 步骤：
>
> > 1. 令X(0)=X，i=0 
> > 2. 求B，这里B={A|(存在V→W)(V→W∈F∧V$ \subseteq$X(i)∧A∈W)}； 
> > 3. X(i+1)=X(i)∪B
> > 4. 判断X(i+1)=X(i)？ 
> > 5. 若相等或X(i)=U 则X(i)就是  ,算法终止。 
> > 6. 若否，则i=i+l，返回第 2) 步。 

:label: 例: 已知关系模式R<U,F>, 其中:U={A,B,C,D,E}；F={AB→C，B→D，C→E，EC→B，AC→B} 求$AB^F_+$   

> 解：由算法4.1，X(0)=AB；计算X(1)； 逐一的扫描F集合中各个函数依赖,找左部为A,B,或AB的函数依赖。得到两个：AB→C，B→D。于是X(1)=AB∪CD=ABCD。
>
> 因为 X(0)≠X(1)，所以再找出左部为ABCD子集的那些函数依赖，又得到C→E，AC→B，于是X(2)=X(1)∪BE=ABCDE。 因为X(2) 已等于全部属性集合,所以(AB)+F =ABCDE

:label: 例：属性集U为ABCD，FD集为｛ A→B，B→C，D→B ｝

> 则用上述算法，可求出:
>
> $A^+=ABC， AD^+=ABCD ， BD^+=BCD$



**函数依赖集的等价覆盖**

:nine: **定义4.9**：设F，G是两个函数依赖集合，如果 $F^+＝\ G^+$ ，则称**F等价于G，或者F与G互相覆盖**。

> 引理4.3： F与G等价的充分必要条件是$F\subseteq G^+ \and G\subseteq F^+$
>
> 要判定$F\subseteq G^+$,只须逐一对F中的函数依赖X→Y，考查Y是否属于$X_{G+}^ +$



:one::zero:<mark> **定义4.10**</mark>：若F满足下列条件:

> F中所有函数依赖的右部均为单属性；
>
> F中不存在这样的函数依赖X→A及Z X，使得$ F^+ ＝(F－\{X→A\}∪\{Z→A\})^+ $，即**F中所有函数依赖的左部没有多余属性**；
>
> F中不存在这样的函数依赖X→A：使得F+ ＝(F－{X→A})+ 即**F中没有多余的函数依赖**

 则称**F为最小函数依赖集或最小覆盖**   :lemon: <font color="orange">有些抽象，可以通过下面具体的例子加以理解</font>

> F的最小依赖集Fmin**不一定唯一**，它和我们对各函数依赖FDi 及X→A中X各属性的处置顺序有关

:star: **示例**： R(A,B,C,D,E,H,I)，F = {A→BE, AH→D, B→C, BD→E, C→D, H→I,I→H,   H→BE}，试求F的最小依赖集Fmin

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203151908050.png" alt="image-20220203151908050" style="zoom:67%;float:left" />

### 多值依赖

![image-20220203153356450](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203153356450.png)

:one: **定义4.11**：

设R(U)是属性集U上的一个关系模式。X，Y，Z是U的子集,并且Z=U-XY。关系模式R(U)中**多值依赖（MVD）X→→Y**成立，当且仅当对R(U)的任一关系r,给定的一对(x，z)值有一组Y的值，这组值仅仅决定于**x值而与z值无关**。

例如，在关系模式TEACHING中，对于(物理，光学原理)有一组T值{李勇，王军}，这组值仅仅决定于课程C上的值(物理)，也就是说对于另一个(物理,普通物理学)它对应的一组T值仍是{李勇,王军}，尽管这时参考书B的值已经改变了。

因此，T多值依赖于C，即C→→T。

:two: **定义4.12：**

设R(U)是属性集U上的一个关系模式。X，Y，Z是的U的子集,并且Z=U-X-Y，如果对R(U)的任一关系r，都有如下性质：如果r中存在2个元组s、t，使得：s[X]=t[X]，则r中必存在元组u，使得：

> (1) s[X]=t[X]=u[X]
>
> (2) u[Y]=t[Y] 且 u[Z]=s[Z]

(即交换s、t在Y上的值得到的2个元组必在r中)

则称关系模式**R满足多值依赖X→→Y**

> •  **一般,当关系至少有三个属性,其中的两个是多值时,且它们的值只依赖于第三个属性时,才会有多值依赖。**
>
> •  **如果关系中存在非平凡非FD的多值依赖则会导致数据冗余和更新异常等问题,所以要消除异常,必须消除多值依赖。**
>
> •  **方法是，通过建立两个关系，让每个关系只存储一个多值属性的数据。**

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203154130571.png" alt="image-20220203154130571" style="zoom:67%;" />

> 函数依赖规定某些元组不能出现在关系中，也称为**相等产生依赖**
>
> 多值依赖要求某种形式的其它元组必须在关系中，称为**元组产生依赖**

## 三、关系模式分解（重点）

<font color="blue">**判断分解是否保持函数依赖和无损连接**</font>

### 关系模式分解定义

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203154615589.png" alt="image-20220203154615589" style="zoom:70%;float:left" />

### 无损连接

#### 定义

定义4.17:设R是一个关系模式，F是R上的一个FD集,ρ=｛ R*1*，…，R*k* ｝ 为R的一个分解,如果对R中满足F的每一个关系r，都有$r=\Pi_{R_1(r)\ \bowtie…\ \bowtie} \Pi_{R_k(r)}$

则称分解ρ相对于F是“无损联接分解” 简称**“无损分解”**，否则，称ρ为“有损联接分解” 简称“有损分解”

示例：多了信息也叫丢失信息

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203155304145.png" alt="image-20220203155304145" style="zoom:67%;float:left" />

#### 判别算法【重点】

![image-20220203155506261](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203155506261.png)

对于只有<font color="red">**2个关系模式**</font>的分解可以通过下面的定理判断其是否为无损联接分解

> **定理4.5：**设ρ=｛ R1，R2 ｝是关系模式R的一个分解，F是R上成立的FD集，那么分解ρ相对于F是无损分解的**充分必要条件**是
>
> （**R1∩R2）→（R1－R2）或（R1∩R2）→（R2－R1）**
>
> 定理4.6：如果FD：X→Y在模式R上成立，且X∩Y=$\emptyset$，则ρ={R－Y，XY }是R的无损分解



:one: **举例1：已知R<U,F>，U={A,B,C}，F={A→B}，如下的两个分解：**

> ① ρ1={AB,BC}
>
> ② ρ2={AB,AC}

判断这两个分解是否具有无损连接性。

> ①因为AB∩BC=B，AB-BC=A，BC-AB=C
>
> 所以$B→A \not\in F^+，B→C \not\in F^+$
>
> 故ρ1是**有损连接**。

> ② 因为AB∩AC=A，AB-AC=B，AC-AB=C
>
> 所以$A→B \in F^+，A→C \not\in F^+$
>
> 故ρ2是**无损连接**。

:two: **举例2：已知R<U,F>，U={A,B,C,D,E}，F={A→C,B→C,C→D,DE→C,CE→A}，R的一个分解为R1(AD)，R2(AB)，R3(BE)，R4(CDE)，R5(AE)，判断这个分解是否具有无损连接性。**

 ① 构造一个初始的二维表，若“属性”属于“模式”中的属性，则填aj，否则填bij

   ![image-20220203160018661](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203160018661.png)                            

② 根据A→C，对上表进行处理，由于属性列A上第1、2、5行相同均为a1，所以将属性列C上的b13、b23、b53改为同一个符号b13（取行号最小值）。

 ![image-20220203160025714](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203160025714.png)

③ 根据B→C，对上表进行处理，由于属性列B上第2、3行相同均为a2，所以将属性列C上的b13、b33改为同一个符号b13（取行号最小值）。

 ![image-20220203160034766](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203160034766.png)

④ 根据C→D，对上表进行处理，由于属性列C上第1、2、3、5行相同均为b13，所以将属性列D上的值均改为同一个符号a4。

 ![image-20220203160041839](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203160041839.png)

⑤ 根据DE→C，对上表进行处理，由于属性列DE上第3、4、5行相同均为a4a5，所以将属性列C上的值均改为同一个符号a3。

 ![image-20220203160046211](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203160046211.png)

⑥ 根据CE→A，对上表进行处理，由于属性列CE上第3、4、5行相同均为a3a5，所以将属性列A上的值均改为同一个符号a1。

 ![image-20220203160052127](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203160052127.png)

⑦ 通过上述的修改，使第三行成为a1a2a3a4a5，则算法终止。且分解具有无损连接性。

### 保持函数依赖的分解

保持关系模式分解等价的另一个重要条件是关系模式的函数依赖集在分解后仍在数据库模式中保持不变。

即关系模式R 到r={R1,R2…Rk}的分解，应使函数依赖集F,被F在这些Ri上的投影蕴涵

**定义4.19**：设ρ=｛ R1，…，Rk ｝是R的一个分解，F是R上的FD集，如果有：$\cup \Pi_{R_i}(F)⊨ F$，则称分解ρ保持函数依赖集F。 

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220203161313736.png" alt="image-20220203161313736" style="zoom:80%;float:left" />

**示例**

![image-20220203161408242](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203161408242.png)

### 模式分解与模式等价问题

关系模式分解的两个特性实际上涉及到两个数据库模式的等价问题，这种**等价包括数据等价和依赖等价**两个方面。

> 数据等价是指两个数据库实例应表示同样的信息内容，用“无损分解”衡量。如果是无损分解，那么对泛关系反复的投影和联接都不会丢失信息。
>
> 依赖等价是指两个数据库模式应有相同的依赖集闭包。在依赖集闭包相等情况下，数据的语义是不会出差错的。
>
> 违反数据等价或依赖等价的分解很难说是一个好的模式设计。

:label: 举例： 关系模式R（ABC），ρ=｛ AB，AC ｝是R的一个分解

试分析分别在F1=｛ A→B ｝，F2=｛ A→C，B→C ｝，F3=｛ B→A ｝，F4=｛ C→B，B→A ｝情况下，检验ρ是否具有无损分解和保持FD的分解特性

解：

相对于F1 =｛ A→B ｝，分解ρ是无损分解且保持FD的分解。

相对于F2 =｛ A→C，B→C ｝，分解ρ是无损分解，但不保持FD集，因为丢失了B→C。

相对于F3 =｛ B→A ｝，分解ρ是损失分解但保持FD集的分解。

相对于F4 =｛ C→B，B→A ｝，分解ρ是损失分解且不保持FD集的分解，因为丢失了C→B。

## 四、关系模式的规范化（重点）

### 范式的概念与分类

•  关系数据库中的关系模式要满足一定的规范化要求，满足不同程度规范化要求的关系模式的类,称为不同的范式(Normal Forms，简记为NF)。

•  范式的种类与数据依赖有着直接的联系，基于FD的范式有1NF、2NF、3NF、BCNF等多种。

•  满足最低要求的关系模式称为第一范式,简称lNF。在第一范式中满足进一步要求的为第二范式，其余以此类推。

•  R为第几范式就写成R∈xNF

•  按属性间依赖情况来区分，关系规范化的程度为1NF,2NF,3NF,BCNF,4NF 和 5NF等 

•  各种范式之间的关系如图所示:

![image-20220203162302265](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203162302265.png)

### 超键SK、候选键CK、主键PK、外键FK

:one: **定义4.21**: 设K为R<U，F>中的属性或属性组合，若$K→U\subseteq F^+$，则称K为R的一个<font color="red">**超键**</font>

> **即在关系模式中，能唯一标识元组的属性集**

:two: **定义4.22**: 如果一个超键K的任何真子集都不再是超键，则称K为R的一个候选键(Candidate key),<font color="red">**候选键**</font>有时也简称为键

> **候选键即一个属性集能唯一标识元组且没有多余的属性**
>
> 若关系模式中有多个候选键，则选定其中的一个为**主键(**Primary key)
>
> 最简单的情况，单个属性是候选键。最极端的情况下，整个属性组是候选键，并称为**全键(All-key**)

:three: **定义4.23**: 包含在任何一个候选键中的属性，称为**主属性**(Prime attribute)或键属性(Key attribute) 。不包含在任何候选键中的属性，则称为**非主属性**(Nonprime attribute)或非键属性(Non-key attribute)

:four: **外键（Froeign Key）**:如果模式R中的属性k是其他模式的主键，那么k在模式R中称为外键。

:label: **例4-14**：关系模式R(P,W,A),属性P表示演奏者，W表示作品,A表示听众。假设一个演奏者可以演奏多个作品，某一作品可被多个演奏者演奏。听众也可以欣赏不同演奏者的不同作品，这个关系模式的候选键为(P,W,A)，即All-key

<mark> **算法4.4:求关系模式上的全部候选键**</mark>

•  输入：关系模式R(U，F)，其中F是最小覆盖

•  输出：R上的所有候选键

•  步骤

> 1)将R的全部属性分为四类，分别是C1：不在任何函数依赖中出现的属性；C2：仅在函数依赖决定子集中（左边）出现的属性；C3：仅在函数依赖右部出现的属性；C4：在函数依赖左部右部均有出现的属性。注意，任何候选键中必然会包括C1、C2中的属性
>
> 2)：若(C1∪C2)+＝U 或者 C4＝空集，则C1∪C2即为惟一的候选键；否则，逐一将C4中的属性加入C1∪C2并计算其闭包，若其闭包为U，则C1∪C2与该属性构成关系上的一个候选键，重复该过程直至找出所有的候选键

•  **示例：求R(A，B，C，D)，F＝{A→B，B→C，BD→A}的所有候选键：**

> 解：C1＝空集，C2＝{D}，C3＝{C}，C4＝{A，B}，(C1∪C2)＋＝{D}，所以C1∪C2不是候选键，依次将C4中的A、B加入C1∪C2中计算其闭包可得：(AD)＋＝ADBC，(BD)＋＝BDAC，所以可知R的候选键为AD和BD

### 第一范式

•  定义4.20：如果关系模式R的每个关系r的属性值都是**不可分的原子值**，则称R是**第一范式(first normal form，简记为1NF)**的模式

•  满足1NF的关系称为规范化的关系，否则称为非规范化的关系

•  **关系数据库研究的关系都是规范化的关系**。

•  例如关系模式R（NAME，ADDRESS，PHONE），如果一个人有两个电话号码（PHONE），那么在关系中至少要出现两个元组，以便存储这两个号码

•  1NF是关系模式应具备的最起码的条件 

•  分量是否需要再分，与具体应用有关,如果用到值的一部分，则需要进一步分割,例如:

<img src="https://gitee.com/yi-junquan/image_gitee/raw/master/images/image-20220203162451396.png" alt="image-20220203162451396" style="zoom:80%;" />

•  如果只是查询出生日期，则它满足1NF

•  如果查询两人生日是否相同，则只比较月、日，需要将生日分解，就不满足1NF

> 



### 第二范式

:star: **定义4.24**：如果关系模式R中的所有**非主属性都完全函数依赖于所有候选键**，则称R满足2NF，表示为R∈2NF。

一个表不属于2NF会存在**插入异常、删除异常、修改复杂**的问题

2NF是在1NF的基础上消除非主属性对于所有候选键的部分函数依赖。

如果数据库模式中每个关系模式都是2NF，则称数据库模式为2NF的数据库模式**。**

:label: **例4-15 :设关系模式R（S#，C#，GRADE，TNAME，TADDR）的属性分别表示学生学号、选修课程的编号、成绩、任课教师姓名和教师地址等意义。（S#，C#）是R的候选键。**

> R上有两个FD：（S#，C#）→（TNAME，TADDR）和C#→（TNAME，TADDR），由于前一个FD是部分依赖，因此R不是2NF模式。
>
> 此时R的关系会出现冗余和异常现象,譬如某一门课程有100个学生选修，那么在关系中就会存在100个元组，因而教师的姓名和地址就会重复100次。
>
> 如果把R分解成R1（C#，TNAME，TADDR）和R2（S#，C#，GRADE）后，部分依赖（S#，C#）→（TNAME，TADDR）就消失了,R1和R2都是2NF模式。 

 :label: 显然，候选键为单键的关系模式符合2NF



### 第三范式

如果关系模式R中的非主属性既**不部分函数依赖也不传递函数依赖**于R上的所有候选键，则称R满足3NF，表示为R∈3NF。

3NF是在2NF的基础上**消除非主属性对于键的传递依赖。**

如果数据库模式中每个关系模式都是3NF，则称其为3NF的数据库模式。

**在例4-15中，R2是2NF模式，而且也是3NF; R1（C#，TNAME，TADDR）是2NF，但不是3NF;因为R1中存在函数依赖C#→TNAME和TNAME→TADDR，C#→TADDR是一个传递依赖,此时R1的关系中也会出现冗余和异常操作;譬如一个教师开设五门课程，那么关系中就会出现五个元组，教师的地址就会重复五次**。

**如果把R2分解成R21（TNAME，TADDR）和R22（C#，TNAME）后，C#→TADDR就不会出现在R21和R22中,R21和R22都是3NF模式** 

**推论1**:如果R是3NF模式，那么R也是2NF模式

**推论2**:设关系模式R，当R上每一个FD X→A满足下列三个条件之一：A∈X（即X→A是一个平凡的FD）；X是R的超键；A是主属性。则关系模式R就是3NF模式

 ![image-20220203165219320](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203165219320.png)

### BCNF

:one: 定义4.26：若对于R上的任何非平凡函数依赖X→Y都有X必包含R的某个候选键，则称R为BCNF，表示为R∈BCNF。

> 定义4.26’：如果关系模式R中的每个属性都不传递依赖于R的候选键，则称R是BCNF模式。

<mark>**BCNF**是在3NF的基础上消除主属性对于键的部分依赖和传递依赖。</mark>

**所有主属性对每一个不包含它的码也是完全函数依赖**

**任何关系模式都可以分解为一组3NF，且既无损连接，又保持函数依赖**

:two: **示例：关系模式SJP(S,J,P)中，S表示学生，J表示课程，P表示名次；每一个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一个学生（即没有并列名次），由语义可得到下面的函数依赖：**

> (S,J)→P ，(J,P)→S 
>
> (S,J)与(J,P)都可以作为候选键。
>
> 这两个键各由两个属性组成,而且它们是相交的
>
> 这个关系模式中显然没有非主属性对键的传递依赖或部分依赖，所以SJP是3NF
>
> 而且除(S,J)与(J,P)以外没有其它决定因素，所以SJP也是BCNF。  

:three: **示例：关系模式STJ(S,T,J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课有若干教师,某一学生选定某门课,就对应一个固定的教师。由语义可得到如下的函数依赖：** 

>  (S,J)→T；(S,T)→J；T→J 
>
>  这里(S,J),(S,T)都是候选键。
>
>  由于STJ中没有非主属性，因此也不会任何非主属性对键传递依赖或部分依赖，所以STJ是3NF。
>
>  但STJ不是BCNF，因为T是决定因素，而T不包含候选键**。**

### 第四范式

:label: 定义4.27:设D是关系模式R上的FD和MVD集合。如果D中每个非平凡的MVD X→→Y的左部X都是R的超键，则称R是4NF的模式。

4NF就是限制**关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖**。

因为根据定义，对于每一个非平凡的多值依赖X→→Y，X都含有候选码，于是就有X→Y，所以4NF所允许的非平凡的多值依赖实际上是函数依赖。

### 判断范式级别(重点)

给定关系模式和函数依赖集合，要求判断达到的**最高范式**。

方法：

求出给定关系的所有候选键(可能不止一个)；

根据键，确定主属性和非主属性；

> 判断是否满足第一范式(看属性的值域是否可以分解）；
>
> 判断是否满足第二范式(非主属性对键的部分函数依赖)； 
>
> 判断是否满足第三范式(非主属性对键的传递函数依赖) ；
>
> 判断是否满足BCNF范式(主属性对键的传递函数依赖)

:one: **示例：已知关系R(A,B,C,D,E)和F={AB→CE,E→AB,C→D},试判断该关系最高为第几范式？**

解：

> 1、关系R的候选键为：AB和E。
>
> 因为:$(AB)^+=\{ABCED\}\qquad        (E)^+=\{EABCD\}$
>
> AB可以决定关系的所有属性，E可以决定关系的所有属性，所以AB 和E是关系的候选键
>
> 2、主属性为：A、B、E，非主属性为：C、D
>
> 3、判断是否满足各个范式的要求：
>
> 因为R的所有的属性值域都是不可再分，所以r已经在1NF中了
>
> 该关系为2NF，因为C、D不存在对任何键的部分依赖
>
> 该关系不是3NF，因为存在非主属性对键的传递依赖C→D
>
> 所以R满足的最高范式是2NF

:two: 示例：已知关系R（A,B,C,D,E,F）和F={A→B,C →DF,AC→E,D→F},该关系最高为第几范式？

> 该关系的键为AC，因为$(AC)^+=\{ACBDFE\}$
>
> 主属性为：A、C
>
> 非主属性为：B,D,E,F
>
> 该关系明显满足1NF，但是由于A→B,C →DF存在非主属性对键的部分函数依赖，所以该关系不是2NF
>
> 所以R满足的最高范式是1NF

:three: 示例：已知关系r（A,B,C,D）和F={AB→D,AC →BD,B→C},试求出其最高范式？

> 该关系的键是：AB和AC
>
> 主属性是{ABC},非主属性是{D}。
>
> D不部分依赖于任何键，所以该关系是2NF。
>
> 该关系也是3NF，因为只有一个非主属性，从而不可能存在两个不同非主属性间的传递依赖
>
> 该关系不是BCNF，因为有B→C，而B不是r的键。

### 分解成3NF模式集的算法

**算法4.6-2 ：将一个关系模式转化为3NF且即无损又保持依赖**

输入：关系R和其上成立的函数依赖集F。

输出：又R分解出的关系集合，其中每个关系均属于3NF。分解具有无损链接和依赖保持性质。

方法：依次执行下列步骤：

找出F的一个最小基本集，记为G。

对于G中的每一个FD X→A，将XA作为分解出的某个关系的模式。

如果第2步分解出的关系的模式均不包含R的超键，则增加一个关系，其模式为R的任何一个键。

**通俗化：**

> **（1）最小化：求最小函数依赖集Fm**
>
> **（2）排除：如果Fm 中某个函数依赖左右属性集包括了全部属性，结束**
>
> **（3）独立：将Fm中不存在的属性，单独构成一个关系子模式**
>
> **（4）分组：合并Fm中的每一个函数依赖**
>
> **（5）添键：如果子模式中都不包含候选键，则把候选键单独构成一个子模式**
>
> **（6）去重：将具有包含关系的子模式，去掉小的部分**
>
> **（7）结束**

保函依赖分解题，先求最小依赖集

依赖两侧未出现，分成子集放一边

剩余依赖变子集，左边相同要合并

添加候选做子集

包含关系要舍去

:one: **举例**

![image-20220203170510830](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203170510830.png)

:two: **示例：对于下列的每个关系模式和FD集合：**

**a) R(A,B,C,D) FD{AB→C,C→D,D→A}**

**b) R(A,B,C,D) FD{B→C,B→D}**

**c) R(A,B,C,D) FD{AB→C,BC→D,CD→A,AD→B}**

**d) R(A,B,C,D) FD{A→B,B→C,C→D,D→A}**

**e) R(A,B,C,D,E) FD{AB→C,DE→C,B→D}**

**f) R(A,B,C,D,E) FD{AB→C,C→D,D→B,D→E}**

**做下列事情：**

**i)** **指出所有的3NF违例。**

**ii)** **如有必要，将关系分解为一系列属于3NF的关系。**

a) R(A,B,C,D) FD{AB→C,C→D,D→A}

> 键：AB、BC、BD
>
> 主属性：A B C D
>
> 满足3NF 

b) R(A,B,C,D) FD{B→C,B→D}

> 键：AB
>
> 主属性：A B
>
> 不满足3NF的FD：B→C,B→D,BC→D,BD→C
>
> 最小函数依赖集：B→C,B→D
>
> 故分解为BC，BD
>
> 均不包含R的超键，故增加AB
>
> 分解结果为BC，BD，AB

c) R(A,B,C,D) FD{AB→C,BC→D,CD→A,AD→B}

> 键：AB、BC、CD、AD
>
> 主属性：A B C D
>
> 满足3NF

d) R(A,B,C,D) FD{A→B,B→C,C→D,D→A}

> 键：A、B、C、D
>
> 主属性：A B C D
>
> 满足3NF

e) R(A,B,C,D,E) FD{AB→C,DE→C,B→D}

> 键：ABE
>
> 主属性：A B E
>
> 非主属性：C D
>
> 满足3NF的FD
>
> AB→C,DE→C,B→D,AB→D,BC→D,BE→C,BE→D,ABC→D,ABD→C,ADE→C,BCE→D,BDE→C
>
> 最小函数依赖集：AB→C,DE→C,B→D
>
> 故分解为ABC，CDE，BD
>
> 均不包含R的超键，故增加ABE
>
> 分解结果为ABC，CDE，BD，ABE 

f) R(A,B,C,D,E) FD{AB→C,C→D,D→B,D→E}

> 键：AB、AC、AD
>
> 主属性：A B C D
>
> 不满足3NF的FD：C→E,D→E,BC→E,BD→E,CD→E,BCD→E
>
> AB→E(AB→C,C→E)
>
> AC→E(AC→D,D→E)
>
> AD→E(AD→C,C→E)
>
> 最小函数依赖集：AB→C,C→D,D→B,D→E
>
> 故分解为ABC，CD，DB，DE
>
> 包含R的超键，即为分解结果

![image-20220203170721203](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203170721203.png)

## 五、补充习题

![image-20220203171039982](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203171039982.png)

![image-20220203171209912](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203171209912.png)

![image-20220203171218671](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203171218671.png)

## 六、课后习题

![image-20220203171346070](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203171346070.png)

![image-20220203171408832](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220203171408832.png)