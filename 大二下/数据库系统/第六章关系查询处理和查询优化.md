

# [XJTUSE DATABASE]——第六章 关系查询处理和查询优化

![image-20230503183503491](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20230503183503491.png)

## 一、关系数据库系统的查询处理

![image-20220205213048397](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205213048397.png)

### 查询分析

查询分析的任务：**对查询语句进行扫描、词法分析和语法分析**。

> 词法分析：从查询语句中识别出正确的语言符号。
>
> 语法分析：进行语法检查。

### 查询检查

**查询检查的任务**

> **合法权检查、视图转换、安全性检查、完整性初步检查**

根据数据字典中有关的模式定义检查语句中的数据库对象，如关系名、属性名是否存在和有效。

如果是对视图的操作，则要用视图消解方法把对视图的操作转换成对基本表的操作**。**

根据数据字典中的用户权限和完整性约束定义对用户的存取权限进行检查。

检查通过后把SQL查询语句转换成内部表示，即等价的关系代数表达式。

关系数据库管理系统一般都用**查询树，也称为语法分析树**来表示扩展的关系代数表达式。 

### 查询优化

查询优化：选择一个高效执行的查询处理策略

查询优化分类

> 代数优化/逻辑优化：指关系代数表达式的优化
>
> 物理优化：指存取路径和底层操作算法的选择

查询优化的选择依据

> **基于规则(rule based)**
>
> **基于代价(cost based)**
>
> **基于语义(semantic based)**

### 查询执行

依据优化器得到的执行策略生成查询执行计划。

代码生成器(code generator)生成执行查询计划的代码。

两种执行方法

> 自顶向下
>
> 自底向上

## 二、关系数据库系统的查询优化

### 查询优化概述

**关系系统的查询优化**

> 是关系数据库管理系统实现的关键技术又是关系系统的优点所在。
>
> 减轻了用户选择存取路径的负担。

**非关系系统**

> 用户使用过程化的语言表达查询要求，执行何种记录级的操作，以及操作的序列是由用户来决定的。
>
> 用户必须了解存取路径，系统要提供用户选择存取路径的手段，查询效率由用户的存取策略决定。
>
> 如果用户做了不当的选择，系统是无法对此加以改进的。

关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案

> 集中式数据库
>
> > 执行开销主要包括
> >
> > **磁盘存取块数(I/O代价)**
> >
> > 处理机时间(CPU代价)
> >
> > 查询的内存开销
> >
> > **I/O代价是最主要的**
>
> 分布式数据库
>
> > 总代价=I/O代价+CPU代价+内存代价＋通信代价



**查询优化的总目标**

> 选择有效的策略
>
> 求得给定关系表达式的值
>
> 使得查询代价最小(实际上是较小)

### 举例说明

求选修了2号课程的学生姓名。

```sql
SELECT Student.Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno AND SC.Cno=’2’
```

假定学生-课程数据库中有1000个学生记录，10000个选课记录，选修2号课程的选课记录为50个

可以用多种等价的关系代数表达式来完成这一查询

![image-20220205214206850](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205214206850.png)

#### 第一种情况

![image-20220205214927708](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205214927708.png)

:one: 计算广义笛卡尔积

> 在内存中尽可能多地装入某个表(如Student表)的若干块，留出一块存放另一个表(如SC表)的元组。
>
> 把SC中的每个元组和Student中每个元组连接，连接后的元组装满一块后就写到中间文件上。
>
> 从SC中读入一块和内存中的Student元组连接，直到SC表处理完。
>
> 再读入若干块Student元组，读入一块SC元组。
>
> 重复上述处理过程，直到把Student表处理完

设一个块能装10个Student元组或100个SC元组，在内存中存放5块Student元组和1块SC元组，

则读取总块数为
$$
\frac{1000}{10}+\frac{1000}{10\times 5}\times \frac{10000}{100}=100+20\times 100=2100块
$$
读Student表100块，读SC表20遍，每遍100块，则总计要读取2100数据块

连接后的元组数为$10^3×10^4=10^7$。设每块能装10个元组，则写出$10^6%$块。

:two: 作选择操作

依次读入连接后的元组，按照选择条件选取满足要求的记录。

假定内存处理时间忽略。读取中间文件花费的时间**(**同写中间文件一样**)**需读入$10^6$块。

若满足条件的元组假设仅**50**个，均可放在内存。

:three: 作投影操作

把第（**2**）步的结果在**Sname**上作投影输出，得到最终结果

:label: <mark>第一种情况下执行查询的总读写数据块=$2100+10^6+10^6$</mark>

#### 第二种情况

![image-20220205214948383](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205214948383.png)

:one: 计算自然连接

执行自然连接，读取**Student**和**SC**表的策略不变，总的读取块数仍为**2100**块

自然连接的结果比第一种情况大大减少，为$10^4$个元组，写出数据块$10^3$

:two: 读取中间文件块，执行选择运算，读取的数据块=$10^3$ 块

:three: 把第2步结果投影输出

:label: <mark>第一种情况下执行查询的总读写数据块=$2100+10^3+10^3$</mark> ,其执行代价大约是第一种情况的488分之一

#### 第三种情况

![image-20220205215258395](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205215258395.png)

:one: 先对**SC**表作选择运算，只需读一遍**SC**表，存取**100**块，因为满足条件的元组仅**50**个，不必使用中间文件。

:two: 读取**Student**表，把读入的**Student**元组和内存中的**SC**元组作连接。也只需读一遍**Student**表共**100**块。

:three: 把连接结果投影输出。

:label: <mark>第三种情况总的读写数据块**=100+100**</mark>，其执行代价大约是第一种情况的万分之一，是第二种情况的**20**分之一。

#### 优化

假如SC表的Cno字段上有**索引**

> 第一步就不必读取所有的SC元组而只需读取Cno=‘2’的那些元组(50个)。
>
> 存取的索引块和SC中满足条件的数据块大约总共3～4块。

若Student表在Sno上也有**索引**

> 不必读取所有的Student元组。 因为满足条件的SC记录仅50个，涉及最多50个Student记录。
>
> 读取Student表的块数也可大大减少

<mark> 有选择和连接操作时，先做选择操作，这样参加连接的元组就可以大大减少，这是代数优化</mark>

在Q3中

> **SC**表的选择操作算法有全表扫描或索引扫描，经过初步估算，索引扫描方法较优。
>
> 对于**Student**和**SC**表的连接，利用**Student**表上的索引，采用索引连接代价也较小，这就是**物理优化**。

## 三、代数优化

代数优化策略：通过对关系代数表达式的等价变换来提高查询效率。

关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的。

两个关系表达式E1 和E2 是等价的，可记为E1 ≡E2

### 关系代数表达式等价变化规则

:one: **连接，笛卡尔积的交换律**

设E1和E2是关系代数表达式，F是连接运算的条件

![image-20220205220021486](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205220021486.png)

:two: **连接，笛卡尔积的结合律**

![image-20220205220052169](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205220052169.png)

:three: **投影的串接定律**

A1…An,B1…Bn为表的属性。

![image-20220205220122542](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205220122542.png)

:four: **选择的串接定律**

![image-20220205220153155](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205220153155.png)

:five: **选择与投影的交换定律**

![image-20220205220217369](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205220217369.png)

:six: **选择与笛卡尔积的交换定律**

![image-20220205220246841](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205220246841.png)

:seven: **选择与并的交换定律**

![image-20220205220655178](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205220655178.png)

:eight: **选择与差的交换定律**

![image-20220205220719355](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205220719355.png)

:nine: **投影与笛卡尔积的交换定律**

![image-20220205220747740](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205220747740.png)

:zero: **投影与并的交换定律**

![image-20220205220818404](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205220818404.png)

### 查询树的启发式优化

#### 典型的启发式规则

:one: **选择运算应尽可能先做**在优化策略中这是最重要、最基本的一条。

:two: **把投影运算和选择运算同时进行**如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。

:three: **把投影同其前或其后的双目运算结合起来**，没有必要为了去掉某些字段而扫描一遍关系。

:four: **把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算**，连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。

:five: 如果这种重复出现的子表达式的结果不是很大的关系并且从外存中读入这个关系比计算该子表达式的时间少得多。则先计算一次公共子表达式并把结果写入中间文件是合算的。当查询的是视图时，定义视图的表达式就是公共子表达式的情况。

#### 查询树

```sql
SELECT Student.Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno AND SC.Cno=’2’
```

把**SQL**语句转换成查询树，如下图所示

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205221117552.png" alt="image-20220205221117552" style="zoom:67%;" />

为了使用关系代数表达式的优化法，假设内部表示是**关系代数语法树**，则上面的查询树如图

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205221159158.png" alt="image-20220205221159158" style="zoom:67%;" />

利用规则把选择σSC.Cno=‘2’**移到叶端，便转换成下图优化的查询树。**即Q3

![image-20220205221319342](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205221319342.png)



## 四、物理优化

**代数优化改变查询语句中操作的次序和组合，不涉及底层的存取路径。**

对于一个查询语句有许多存取方案，它们的执行效率不同， 仅仅进行代数优化是不够的。

物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划。

 **物理优化方法**

> 两者结合的优化方法：
>
> 常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量。
>
> 然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案。

### 基于启发式规则的存取路径选择优化

#### 选择操作的启发式规则

对于小关系，使用全表顺序扫描，即使选择列上有索引

**对于大关系，启发式规则有**：

:one: **对于选择条件是“主码＝值”的查询**

> 查询结果最多是一个元组，可以选择主码索引。一般的关系数据库管理系统会自动建立主码索引。

:two: **对于选择条件是“非主属性＝值”的查询，并且选择列上有索引。**

> 要估算查询结果的元组数目。如果比例较小(<10%)可以使用索引扫描方法。否则还是使用全表顺序扫描

:three: **对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引。**

> 要估算查询结果的元组数目,如果比例较小(<10%)可以使用索引扫描方法。否则还是使用全表顺序扫描。

:four: **对于用AND连接的合取选择条件**

> 如果有涉及这些属性的组合索引优先采用组合索引扫描方法
>
> 如果某些属性上有一般的索引，可以用索引扫描方法
>
> 通过分别查找满足每个条件的指针，求指针的交集
>
> 通过索引查找满足部分条件的元组，然后在扫描这些元组时判断是否满足剩余条件。
>
> 其他情况：使用全表顺序扫描。

:five: **对于用OR连接的析取选择条件，一般使用全表顺序扫描。**

#### 连接操作的启发式规则

:one: 如果2个表都已经按照连接属性排序

选用排序-合并算法。

:two: 如果一个表在连接属性上有索引

选用索引连接算法。

:three: 如果上面2个规则都不适用，其中一个表较小

选用Hash join算法。

:four: 可以选用嵌套循环方法，并选择其中较小的表，确切地讲是占用的块数(b)较少的表，作为外表(外循环的表)

### 基于代价的优化

#### 统计信息

基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它与数据库的状态密切相关

优化器需要的统计信息

**对每个基本表**

> 该表的元组总数(N)元组长度(l)、占用的块数(B、占用的溢出块数(BO)

**对基表的每个列**

> 该列不同值的个数(m)、列最大值、最小值
>
> 列上是否已经建立了索引
>
> 哪种索引(B+树索引、Hash索引、聚集索引)
>
> 可以计算选择率(f)
>
> 如果不同值的分布是均匀的，*f*＝1/m
>
> 如果不同值的分布不均匀，则要计算每个值的选择率，*f*＝具有该值的元组数/N

**对索引**

> 索引的层数(L)。
>
> 不同索引值的个数。
>
> 索引的选择基数S(有S个元组具有某个索引值)。
>
> 索引的叶结点数(Y)。

#### 代价估算示例

**全表扫描算法的代价估算公式**

> 如果基本表大小为**B**块，全表扫描算法的代价 **cost**＝**B**
>
> 如果选择条件是“码＝值”，那么平均搜索代价 cost＝B/2

**索引扫描算法的代价估算公式**

:one: **如果选择条件是“码＝值”**

> 则采用该表的主索引。
>
> 若为**B+**树，层数为**L**，需要存取**B+**树中从根结点到叶结点**L**块，再加上基本表中该元组所在的那一块，所以**cost=L+1。**

:two: **如果选择条件涉及非码属性**

> 若为**B+**树索引，选择条件是相等比较，**S**是索引的选择基数**(**有**S**个元组满足条件**)。**
>
> 满足条件的元组可能会保存在不同的块上，所以**(**最坏的情况**)cost=L+S。**

:three: **如果比较条件是＞，＞＝，＜，＜＝操作**

> 假设有一半的元组满足条件就要存取一半的叶结点
>
> 通过索引访问一半的表存储块**cost=L+Y/2+B/2**
>
> 如果可以获得更准确的选择基数，可以进一步修正**Y/2**与**B/2**

:four: **嵌套循环连接算法的代价估算公式**

> 嵌套循环连接算法的代价**cost**＝**Br+BrBs/(K-1)**
>
> 如果需要把连接结果写回磁盘**cost**＝**Br+Br Bs/(K-1)+(Frs\*Nr\*Ns)/Mrs**
>
> > 其中**Frs**为连接选择性**(join selectivity)**，表示连接结果元组数的比例。
> >
> > 设连接表**R**与**S**分别占用的块数为**Br**与**Bs**
> >
> > **Mrs**是存放连接结果的块因子，表示每块中可以存放的结果元组数目。

:five: **排序-合并连接算法的代价估算公式**

> 如果连接表已经按照连接属性排好序，则**cost**＝**Br+Bs+(Frs\*Nr\*Ns)/Mrs**
>
> 如果必须对文件排序还需要在代价函数中加上排序的代价。对于包含**B**个块的文件排序的代价大约是**(2\*B)+(2\*B\*log2B)。**

## 五、习题

![image-20220205222505899](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205222505899.png)

![image-20220205222519454](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220205222519454.png)

![image-20220205222532087](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205222532087.png)

![image-20220205222551778](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205222551778.png)

![image-20220205222618286](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220205222618286.png)

## 参考博客

https://blog.csdn.net/qq_38258510/article/details/105974908

